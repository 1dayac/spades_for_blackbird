include: "Common.snake"

import yaml

reassembly_config = config.get("reassembly", dict())
COV_CUTOFF = reassembly_config.get("cov_cutoff", 0.3)
READ_LENGTH = config.get("read_length", 100) #TODO: auto-detect default value

#Autodetecting bins for reassembly based on the choose_samples result in the main pipeline
BINS, = glob_wildcards("reassembly/{{bin,{}}}.info".format(NAME_TEMPLATE))
if not BINS:
    raise WorkflowError("No bins detected!")

rule reassemble_all:
    input:   expand("reassembly/bins/{bin}.fasta", bin=BINS)
    message: "Reassembly finished."

rule reassembly_config:
    input:   "reassembly/{bin}.info"
    output:  "reassembly/{bin}.yaml"
    message: "Generating config file for reassembly of {wildcards.bin}"
    run:
        with open(output[0], "w") as outfile:
            conf = {"k": PROFILE_K, "sample_cnt": SAMPLE_COUNT,
                    "kmer_mult": "profile/mts/kmers",
                    "bin": wildcards.bin, "bin_prof": "binning/{}/bins.prof".format(BINNER),
                    "edges_sqn": "reassembly/{}/edges.fasta".format(wildcards.bin),
                    "edges_mpl": "reassembly/{}/edges.mpl".format(wildcards.bin),
                    "edge_fragments_mpl": "reassembly/{}/edges_frag.mpl".format(wildcards.bin),
                    "frag_size": SPLIT_LENGTH, "min_len": 100}
            yaml.dump(conf, outfile)

#For bin reassembly, we choose only matching reads from samples which were marked with +
#in the corresponding {bin}.info file
BIN_READS = dict()
for bin in BINS:
    with open("reassembly/{}.info".format(bin)) as samples_info:
        samples = []
        for line in samples_info:
            sample_data = line.split()
            if sample_data[0][0] == "+":
                sample = sample_data[0][1:]
                if not os.path.exists("reads/{}/{}_1.fastq.gz".format(bin, sample)):
                    print("\033[33mWarning: {} contains no reads for {}\033[0m".format(sample, bin))
                    continue
                samples.append(sample)
        BIN_READS[bin] = (["reads/{}/{}_1.fastq.gz".format(bin, sample) for sample in samples],
                          ["reads/{}/{}_2.fastq.gz".format(bin, sample) for sample in samples])

def bin_reads(dir, wildcards):
    return BIN_READS[wildcards["bin"]][dir]

#Returns the filepath with left/right reads for a sample or list of them for a group, used as Snakemake input
left_bin_reads, right_bin_reads = reads_input(bin_reads)

#TODO: gzip subsampled reads
rule subsample:
    input:   info="reassembly/{bin}.info"
    output:  "reassembly/{bin}/left.fq", "reassembly/{bin}/right.fq", "reassembly/{bin}/total.cov"
    params:  "reads/{bin}", "reassembly/{bin}"
    log:     "reassembly/{bin}/subsample.log"
    message: "Subsampling reads for {wildcards.bin}"
    shell:   "{SCRIPTS}/subsample.py {input} {params} >{log}"

rule reassemble:
    input:   left="reassembly/{bin}/left.fq", right="reassembly/{bin}/right.fq",
             config="reassembly/{bin}.yaml", cov="reassembly/{bin}/total.cov"
    output:  "reassembly/bins/{bin}.fasta"
    params:  out="reassembly/{bin}"
    log:     "reassembly/{bin}.log"
    threads: THREADS
    message: "Reassembling reads for {wildcards.bin}"
    run:
        subtotal = float(open(input.cov).readline())
        bin_cov = COV_CUTOFF * subtotal * (READ_LENGTH - ASSEMBLY_K) / (READ_LENGTH - PROFILE_K)
        shell("{REASSEMBLER_DIR}/spades.py --meta --only-assembler -t {threads}"
             " --pe1-1 {input.left} --pe1-2 {input.right} --pe1-ff -o {params.out}"
             " --hidden-cov-cutoff {bin_cov} --series-analysis {input.config}"
             " >{log} 2>&1 && cp {params.out}/scaffolds.fasta {output}")
