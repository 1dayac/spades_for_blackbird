from scripts.common import gather_refs

#Additional config parameters
try:
    QUAST_DIR = config["stats"]["quast"]
    QUAST = os.path.join(QUAST_DIR, "quast.py")
    METAQUAST = os.path.join(QUAST_DIR, "metaquast.py")
except KeyError:
    QUAST = "quast"
    METAQUAST = "metaquast"

#Detect references
REFS = dict(gather_refs(config["stats"].get("refs", [])))
REFS_STR = ",".join(path for path in REFS.values())

class Input:
    def __init__(self, fasta_template, fragments):
        self.fragments = fragments
        self.input = expand(fasta_template, frag=fragments)

input_dict = dict()

def register_input(stage, *args):
    global input_dict
    input_dict[stage] = Input(*args)

def stats_input(wildcards):
    return input_dict[wildcards.stage].input

def all_input(wildcards):
    return input_dict.values()

rule genome_fraction:
    input:   stats_input
    output:  "stats/summary/gf_{stage}.tsv"
    params:  out="stats/q_{stage}"
    log:     "stats/q_{stage}/.log"
    threads: THREADS
    message: "Aligning all of {wildcards.stage} on all references"
    shell:   "{METAQUAST} -t {threads} -R {REFS_STR} {input} -o {params.out} >/dev/null 2>&1 && "
             "cp '{params.out}/summary/TSV/Genome_fraction_(%).tsv' {output}"

rule gf_all:
    input:   all_input
    output:  touch("stats/gf_all.done")
    message: "Gathered GF on all stages"

#---- Contigs of interest ------------------------------------------------------
rule filter_ref_alignments:
    input:   "stats/summary/gf_{stage}.tsv"
    output:  "stats/q_{stage}/runs_per_reference/{ref}/{fragments}.info"
    params:  "stats/q_{stage}/runs_per_reference/{ref}/contigs_reports/nucmer_output/{fragments}.coords.filtered"
    message: "Filtering alignments of {wildcards.fragments} from {wildcards.stage} onto {wildcards.ref}"
    shell:   "if [ -f {params} ] ; then {SCRIPTS}/filter_nucmer.py {params} {output} {MIN_CONTIG_LENGTH} 70 ; else touch {output} ; fi"

def alignment_input(wildcards):
    template = "stats/q_{}/runs_per_reference/{{ref}}/{{fragments}}.info".format(wildcards.stage)
    return expand(template, ref = wildcards.ref, fragments=input_dict[wildcards.stage].fragments)

rule combine_alignment_info:
    input:   alignment_input
    output:  "stats/q_{stage}/g_{ref}.info"
    message: "Combining good contigs of {wildcards.stage} for {wildcards.ref}"
    shell:   "rm -rf {output}; for f in {input}; do name=$(basename $f .info); cat $f | sed 's/^/'$name'-/g' >> {output} ; done"

rule combine_refs_info:
    input:   expand("stats/q_{{stage}}/g_{ref}.info", ref=list(REFS.keys()))
    output:  "stats/q_{stage}/total.info"
    message: "Combining good contigs of {wildcards.stage} for all references"
    run:
        shell("rm -f {output}")
        for ref in REFS.keys():
            shell("awk '{{print $0 \"\t{ref}\"}}' stats/q_{wildcards.stage}/g_{ref}.info >> {output}")

#---- Summary table ------------------------------------------------------------
rule gather_stats:
    input:   "stats/summary/gf_{stage}.tsv",
             "stats/q_{stage}/total.info"
    output:  "stats/summary/{stage}_summary.tsv"
    params:  "--problematic", "--heatmap", "stats/q_{stage}", "stats/summary/{stage}"
    message: "Gathering {wildcards.stage} stats"
    shell:   "{SCRIPTS}/gather_stats.py {params}"

#---- CheckM stats -------------------------------------------------------------
rule checkm:
    input:   stats_input
    output:  qa="stats/checkm_{stage}/qa.tsv", tree_qa="stats/checkm_{stage}/tree_qa.tsv"
    params:  out="stats/checkm_{stage}",
    threads: THREADS
    run:
        dir = os.path.dirname(input_dir[wildcards.stage])
        _, ext = os.path.splitext(input_dir[wildcards.stage])
        ext = ext[1:]
        shell("set +u; source activate concoct_env; set -u \n"
             "checkm tree -x {ext} {dir} {out} \n"
             "checkm tree_qa -o 2 --tab_table -f {output.tree_qa} {params.out}\n"
             "checkm lineage_set {params.out} {params.out}/lineage.ms\n"
             "checkm analyze -x fasta {params.out}/lineage.ms reassembly {params.out}\n"
             "checkm qa -o 2 --tab_table -f {output.qa} {params.out}/lineage.ms {params.out}")

rule parse_checkm:
    input:   qa=rules.checkm.output.qa, tree_qa=rules.checkm.output.tree_qa
    output:  "stats/summary/checkm_{stage}.tsv"
    #shell:   "{SCRIPTS}/parse_checkm.py {input.qa} {input.tree_qa} > {output}"
    run:
        table = pandas.read_table(input.qa, dtype="str")
        tree_table = pandas.read_table(input.tree_qa, dtype="str", na_filter=False)
        all_table = pandas.merge(table, tree_table, on="Bin Id")
        res_table = all_table[["Bin Id", "Taxonomy (contained)", "Taxonomy (sister lineage)", "Genome size (Mbp)", "Completeness", "Contamination"]].copy()
        def extract_taxon(taxonomy):
            return str(taxonomy).split(";")[-1]
        for column in ["Taxonomy (contained)", "Taxonomy (sister lineage)"]:
            res_table[column] = res_table[column].apply(extract_taxon)
        res_table.to_csv(output[0], index=False, sep="\t")
