configfile: "config.yaml"

import os
import os.path

def gather_refs(data):
    if type(data) is list:
        for path in data:
            yield from gather_refs(path)
    else:
        if os.path.isdir(data):
            for path in os.listdir(data):
                if path.endswith(".fasta") or path.endswith(".fna"):
                     yield os.path.join(data, path)
        else:
            yield data

IN = config["IN"]
SPADES = config["SPADES"]
BIN = config["BIN"]
SCRIPTS = config["SCRIPTS"]
SOFT = config["SOFT"]
QUAST = config["QUAST"]
K = int(config.get("K", 55))
Kp = K + 1
SAVES = "K{0}/saves/07_before_repeat_resolution/graph_pack".format(K)
MIN_CONTIG_LENGTH = int(config["MIN_CONTIG_LENGTH"])
CAG = config.get("CAG")
THREADS = config.get("THREADS", 24)
SAMPLES, = glob_wildcards(IN + "/{sample,sample\d+}")
SAMPLE_COUNT = len(SAMPLES)
REFS = {os.path.splitext(os.path.basename(fullpath))[0]: fullpath for fullpath in gather_refs(config.get("REFS", []))}
def ref_path(wildcards):
    return REFS[wildcards.ref]

# ---- Targets section ---------------------------------------------------------

rule all:
    input:   expand("{sample}/binning.log", sample=SAMPLES)
    message: "Dataset has been binned."

rule assemble:
    input:   left = IN + "/{sample}/left.fastq", right = IN + "/{sample}/right.fastq"
    output:  "{sample}/{sample}.fasta"
    params:  "{sample}/assembly"
    log:     "{sample}/assembly.log"
    threads: THREADS
    message: "Assembling {wildcards.sample} with SPAdes"
    shell:
        "mkdir -p {wildcards.sample} && "
        "{SPADES}/spades.py --meta -t {threads} -1 {input.left} -2 {input.right} -o {params} >{log} 2>&1 && "
        "cp {params}/scaffolds.fasta {output}"

rule descriptions:
    output:  expand("{sample}.desc", sample=SAMPLES)
    message: "Generating sample descriptions"
    shell:   "{SCRIPTS}/dataset_desc_gen.sh {IN}/sample ./ >/dev/null"

rule multiplicities:
    input:   expand("{sample}.desc", sample=SAMPLES)
    output:  "kmers.mpl"
    log:     "multiplicities.log"
    message: "Gathering {Kp}-mer multiplicities from {input}"
    shell:
        "mkdir -p tmp && "
        "export PATH={SOFT}:$PATH && "
        "{BIN}/kmer_multiplicity_counter -k {Kp} -o kmers --mult 2 --sample 3 -d {input} >{log} 2>&1"

rule profile:
    input:   contigs="{sample}/{sample}.fasta", mpl="kmers.mpl"
    output:  "{sample}/{sample}.id"
    log:     "{sample}/profile.log"
    message: "Counting contig abundancies for {wildcards.sample}"
    shell:
        "{BIN}/contig_abundance_counter -k {K} -s {wildcards.sample}/assembly/{SAVES} -c {input.contigs} -n {SAMPLE_COUNT} -m kmers -o {wildcards.sample}/{wildcards.sample} -l {MIN_CONTIG_LENGTH} >{log} 2>&1"

rule canopy_pre:
    input:   expand("{sample}/{sample}.id", sample=SAMPLES)
    output:  "canopy.in"
    message: "Preparing canopy input"
    shell:   "{SCRIPTS}/make_canopy_input.py {output} {input}"

rule canopy:
    input:   rules.canopy_pre.output
    output:  out = "canopy.out", prof = "canopy.prof"
    message: "Running canopy clustering"
    shell:   "{SCRIPTS}/canopy_launch.sh {input} {output.out} {output.prof}"

rule canopy_post:
    input:   rules.canopy.output.out
    output:  expand("{sample}.ann", sample=SAMPLES)
    message: "Preparing raw annotations"
    shell:   "{SCRIPTS}/parse_canopy_out.py {input} ./"

rule propagate:
    input:   "{sample}/{sample}.fasta", "{sample}.ann"
    output:  "{sample}.ann.prop"
    message: "Propagating annotations for {wildcards.sample}"
    shell:   "{BIN}/annotation_propagator {K} {wildcards.sample}_assembly/{CONFIG} {wildcards.sample}_assembly/{SAVES} {input} {output}"

rule binning:
    input:
        contigs="{sample}/{sample}.fasta", ann="{sample}.ann",
        left=IN + "/{sample}/left.fastq", right=IN + "/{sample}/right.fastq"
    output:  "{sample}/binning.log"
    params:  "{sample}"
    log:     "{sample}/binning.log"
    message: "Propagating annotation & binning reads for {wildcards.sample}"
    #TODO: non-file output?
    shell:
        "{BIN}/prop_binning -k {K} -s {wildcards.sample}/assembly/{SAVES} -c {input.contigs} -a {input.ann} -l {input.left} -r {input.right} -o binning -n {params} >{log} 2>&1 &&"
        "touch {output}"

rule reassemble:
    input:   "{sample}/binning.log"
    output:  "{sample}/reassembly_{cag}.fasta"
    params:  left="binning/{cag}/{sample}_1.fastq", right="binning/{cag}/{sample}_2.fastq", out="{sample}/reassembly_{cag}"
    log:     "{sample}/reassembly_{cag}.log"
    threads: THREADS
    message: "Reassembling reads for {wildcards.cag} from {wildcards.sample}"
    shell:
        "{SPADES}/spades.py --meta -t {threads} -1 {params.left} -2 {params.right} -o {params.out} >{log} 2>&1 && "
        "cp {params.out}/scaffolds.fasta {output}"

#Todo: report error when CAG is unset
rule reassemble_all:
    input:   expand("{sample}/{cag}.fasta", sample=SAMPLES, cag=CAG)
    message: "Reassembling reads for {CAG}"

# rule quast:
#     input:   ref=ref_path, contigs="{sample}/{sample}.fasta"
#     output:  "{sample}/{ref}.cont"
#     log:     "{sample}/q_{ref}"
#     message: "Aligning {wildcards.sample} on {wildcards.ref} & looking for interesting contigs"
#     shell:
#         "{QUAST} -R {input.ref} {input.contigs} -o {log} &&"
#         "{SCRIPTS}/filter_nucmer.py {log} {wildcards.sample} 70 > {output}"

rule quast_all_samples:
    input:   ref=ref_path, contigs=expand("{sample}/{sample}.fasta", sample=SAMPLES)
    output:  "summary/q_{ref}/report.tsv"
    params:  "summary/q_{ref}"
    log:     "summary/q_{ref}.log"
    message: "Aligning all samples on {wildcards.ref}"
    shell:   "{QUAST} -R {input.ref} {input.contigs} -o {log} >{log} 2>&1"

rule filter_all_samples:
    input:   "summary/q_{ref}/report.tsv"
    output:  expand("{sample}/{{ref}}.cont", sample=SAMPLES)
    message: "Filtering interesting contigs from all samples for {wildcards.ref}"
    params:  "summary/q_{ref}/"
    shell:   "{SCRIPTS}/filter_nucmer.py {params} {wildcards.ref}.cont 70"

rule quast_all:
    input:   expand("{sample}/{ref}.cont", sample=SAMPLES, ref=REFS.keys())
    message: "Calculated QUAST metrics"

rule pca:
    input:   rules.canopy_pre.output, rules.canopy.output.out, "{sample}.cont"
    output:  "{sample}.png"
    message: "Doing some visualization"
    shell:
        "Rscript {SCRIPTS}/pca.R {input} {output}"

rule bins:
    input:   "{sample}/{ref}.cont"
    output:  "{sample}/{ref}.bin"
    message: "Filtering interesting bins for {wildcards.sample} aligned to {wildcards.ref}"
    shell: "Rscript {SCRIPTS}/bins.R canopy.out {input} > {output}"

rule bins_all_samples:
    input:   expand("{sample}/{{ref}}.bin", sample=SAMPLES)
    output:  "summary/{ref}.bin"
    message: "Gather interesting bins for {wildcards.ref} from all samples"
    run:
        bins = set()
        for in_fn in input:
            with open(in_fn) as infile:
                for line in infile:
                    bins.add(line)
        with open(output[0], "w") as outfile:
            for bin in bins:
                print(bin, file=outfile)

rule bins_all:
    input:   expand("summary/{ref}.bin", ref=REFS)
    message: "Gather all interesting bins"

rule prop_stats:
    input:   prelim="{sample}.ann", prop="{sample}.ann.prop", bins="{sample}/{ref}.bin", contigs="{sample}/{sample}.fasta", ref=ref_path
    output:  "{sample}/{ref}.stats"
    message: "Calculating propagation statistics for {wildcards.sample} aligned to {wildcards.ref}"
    shell:   "{BIN}/stats -k {K} -s {wildcards.sample}/assembly/{SAVES} -r {input.ref} -c {input.contigs} -a {input.prelim} -p {input.prop} -b `cat {input.bins}` >/dev/null 2>{output}"

rule prop_stats_all:
    input:   expand("{sample}/{ref}.stats", sample=SAMPLES, ref=REFS.keys())
    message: "Calculated basic stats"
