include: "Common.snake"
include: "CommonStats.snake"

import os
import os.path

import pandas
from pandas import DataFrame

from scripts.common import dump_dict

#Additional config parameters
try:
    QUAST_DIR = config["QUAST"]
    QUAST = os.path.join(QUAST_DIR, "quast.py")
    METAQUAST = os.path.join(QUAST_DIR, "metaquast.py")
except KeyError:
    QUAST = "quast"
    METAQUAST = "metaquast"

#Autodetect bins
CAGS, = glob_wildcards("binning/{cag,CAG\d+}/left.fastq")
CAGS.sort()

CAG_EDGES = [c + "_edges" for c in CAGS]

#Detect references
REFS = dict(gather_refs(config.get("REFS", [])))
ALL_REFS = ",".join(path for path in REFS.values())

def ref_path(wildcards):
    return REFS[wildcards.ref]

onstart:
    try:
        os.mkdir("tmp")
    except:
        pass
    print("Detected", SAMPLE_COUNT, "samples in", IN)
    if CAGS:
        print("Detected good (abundant) CAGs:", " ".join(CAGS))
    if REFS:
        print("Detected references:", " ".join(REFS))

#===============================================================================
#---- Statistics section -------------------------------------------------------
#===============================================================================

register_input("assembly", "assembly/{frag}.fasta", GROUPS)
register_input("reassembly_edges", "profile/{frag}.fasta", CAG_EDGES)

#---- GF per bin per reference -------------------------------------------------

#Helper formatters for determining input files from different stages
SUBSTAGES = ["prelim", "prop"]
SUB_DEPS = {"prelim": ("assembly/{}_splits.fasta",   "annotation/{}.ann"),
            "prop":   ("propagation/{}_edges.fasta", "propagation/{}_edges.ann")}

#Redistribute sample pieces to corresponding CAGs
#TODO: split into different directories per sample
rule split_bins:
    input:   lambda w: SUB_DEPS[w.substage][0].format(w.sample),
             lambda w: SUB_DEPS[w.substage][1].format(w.sample)
    output:  touch("binning/{substage}/{sample}.log")
    log:     "binning/{substage}/split_{sample}.log"
    params:  "binning/{substage}"
    message: "Splitting {wildcards.sample} between {wildcards.substage} bins"
    shell:   "{SCRIPTS}/split_bins.py {input} {params} >{log}"

rule cat_binned_contigs:
    input:   expand("binning/{{prop}}/{sample}.log", sample=GROUPS)
    output:  "binning/{prop}/{cag,CAG\d+}.fasta"
    params:  "`ls binning/{prop}/*-{cag}.fasta`"
    message: "Combine binned contigs ({wildcards.prop}) for {wildcards.cag}"
    shell:   "cat {params} > {output}"

for substage in SUBSTAGES:
    register_input("bin_{}".format(substage), "binning/{}/{{frag}}.fasta".format(substage), CAGS)

#Run this
rule stats_assembly:
    input:   expand("stats/summary/gf_bin_{substage}.tsv", substage=SUBSTAGES),
             "stats/q_assembly/total.info"
    message: "Gathered some numbers, deal with them."

#---- Reassembly statistics ----------------------------------------------------

register_input("reassembly", "reassembly/{frag}.fasta", CAGS)

#Run this
rule stats_reassembly:
    input:   "stats/summary/gf_reassembly.tsv",
             "stats/q_reassembly/total.info"
    output:  "stats/summary/reassembly.tsv"
    params:  "stats/q_reassembly"
    message: "Gathered bins stats"
    shell:   "{SCRIPTS}/gather_stats.py {params} > {output}"

#---- Propagator statistics ----------------------------------------------------
rule prop_stats:
    input:   prelim="annotation/{sample}.ann", prop="annotation/{sample}_edges.ann",
             contigs="assembly/{sample}.fasta", edges="assembly/{sample}_edges.fasta",
             ref=REFS.values() #, bins="{sample}/{ref}.bin"
    output:  "stats/prop_{cag}/{sample}.tsv"
    log:     "stats/prop_{cag}/{sample}.log"
    message: "Calculating propagation statistics for {wildcards.sample}"
    shell:   "{BIN}/stats -k {K} -s {wildcards.sample}/assembly/{SAVES} -r {input.ref}"
             " -c {input.contigs} -a {input.prelim} -e {input.edges} -p {input.prop}"
             " -b {wildcards.cag} -o {output} >{log}"

# Run this
rule prop_stats_all:
    input:   expand("stats/prop_{cag}/{sample}.tsv", sample=GROUPS, cag=CAGS)
    message: "Calculated propagation statistics"

#---- CheckM stats -------------------------------------------------------------
rule checkm:
    input:   expand("reassembly/{cag}.fasta", cag=CAGS)
    output:  qa="stats/checkm/qa.tsv", tree_qa="stats/checkm/tree_qa.tsv"
    params:  dir="stats/checkm"
    threads: THREADS
    shell:   "set +u; source activate concoct_env; set -u \n"
             "checkm tree -x fasta reassembly {params.dir} \n"
             "checkm tree_qa -o 2 --tab_table -f {output.tree_qa} {params.dir}\n"
             "checkm lineage_set {params.dir} {params.dir}/lineage.ms\n"
             "checkm analyze -x fasta {params.dir}/lineage.ms reassembly {params.dir}\n"
             "checkm qa -o 2 --tab_table -f {output.qa} {params.dir}/lineage.ms {params.dir}"

rule parse_checkm:
    input:   qa=rules.checkm.output.qa, tree_qa=rules.checkm.output.tree_qa
    output:  "stats/summary/checkm.tsv"
    #shell:   "{SCRIPTS}/parse_checkm.py {input.qa} {input.tree_qa} > {output}"
    run:
        table = pandas.read_table(input.qa, dtype="str")
        tree_table = pandas.read_table(input.tree_qa, dtype="str", na_filter=False)
        all_table = pandas.merge(table, tree_table, on="Bin Id")
        res_table = all_table[["Bin Id", "Taxonomy (contained)", "Taxonomy (sister lineage)", "Genome size (Mbp)", "Completeness", "Contamination"]].copy()
        def extract_taxon(taxonomy):
            return str(taxonomy).split(";")[-1]
        for column in ["Taxonomy (contained)", "Taxonomy (sister lineage)"]:
            res_table[column] = res_table[column].apply(extract_taxon)
        res_table.to_csv(output[0], index=False, sep="\t")

#---- PCA ----------------------------------------------------------------------
FRAGMENT_NAMES_BY_STAGE = {"reassembly": CAG_EDGES,
                           "assembly": list(GROUPS.keys())}

def fragments_info_by_stage(wildcards):
    fragments=FRAGMENT_NAMES_BY_STAGE[wildcards.stage]
    return expand("stats/q_{stage}/runs_per_reference/{ref}/{fs}.info", stage=wildcards.stage, ref=wildcards.ref, fs=fragments)

rule pca:
    input:   "binning/canopy/profiles.in", "binning/canopy/binning.out", "stats/q_{stage}/total.info"
    output:  "stats/summary/pca_{stage}.png"
    message: "Drawing PCA visualisation for {wildcards.stage}"
    shell:   "Rscript {SCRIPTS}/pca.R {input} {output}"

# Run this
rule pca_all:
    input:   expand("stats/summary/pca_{stage}.png", stage=FRAGMENT_NAMES_BY_STAGE.keys())
    message: "Drew all PCAs"
