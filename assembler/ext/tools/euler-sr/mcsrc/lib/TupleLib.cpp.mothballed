#include "TupleLib.h"
#include <ios>
#include <iostream>
#include <iomanip>
#include <fstream>

#include "SeqUtils.h"

// raw ascii complement map: 
// A(65) -> T(84)
// C(67) -> G(71)
// T(84) -> A(65)
// G(71) -> C(67)
// a(97) -> t(116)
// c(99) -> g(103)
// t(116)-> a(97)
// g(103)-> c(99)

// binary encoding complement


long Node::total_nodes = 0;
int Node::totalLookups = 0;
int Node::totalReferences = 0;

Node* getNode(Node* head, Tuple val) {
  Node::totalLookups++;
  while (head != NULL && head->value != val) {
    head = head->next;
    Node::totalReferences++;
  }

  if (head == NULL) return NULL;
  else return head;
}


void RotateAlignment(int *alignment, int alignLength, int alignSpan) {
  int i;
  for (i = 0; i < alignLength ; i++) {
    if (alignment[i] != -1)
      alignment[i] = alignSpan - alignment[i] - 1;
  }
}




void findCommon(Node *tableA[], Node *tableB[], long tableSize, int
		probe_len, int word_len) {
  // This will find all common tuples.
  // The input is a table of chained nodes.  Each node has the
  // property that if it is unique, node->match = node, and if it is
  // not unique, node->match = NULL.  Since we are looking for unique
  // shared, do not assign anything that is not unique a match.
  long i;
  Node *node;
  Node *match, *matchParent;
  long numCommon = 0;
  long n = 0;
  for (i = 0; i < tableSize; i++) {
    node = tableA[i];
    // Follow the chain for this entry in the hash table
    while (node != NULL) {
      // node->match is null when this node is not unique within its own sequence.
      n++;
      if (node->match != NULL) {
	findNode(tableB, match, node->value, probe_len, word_len);
	if (match != NULL) {
	  node->match = match;
	  numCommon++;
	}
	else {
	  node->match = NULL;
	}
      }
      if (node == node->next) {
	std::cout << "Something is wrong with the table structure, bailing out " << std::endl;
	exit(0);
      }
      node = node->next;
      if (n % 100000 == 0) {
	std::cout << "Searched through " << n << " nodes for common " << std::endl;
      }
    }
  }
}

void MaskNotUnique(DNASequence &seq1, DNASequence &seq2,
		   int dist, int doIndel,
		   int hashLength, int wordLength) {
  int i, j;

  long tempStartPos;
  // Create the hash table to record tuple multiplicities.
  Node** table;
  AllocateTable(table, wordLength);

  // Count the multiplicity of all tuples
  StoreGenome(seq1, tempStartPos, table, hashLength, wordLength);
  StoreGenome(seq2, tempStartPos, table, hashLength, wordLength);

  // Check to see if each tuple is unique.
  int pos;
  Tuple tuple;
  Node  *node;
  int numNeighbors;
  Tuple neighboringTuple;
  int isUnique;
  int hasNeighbor;
  
  // Mask forward seq1 
  pos = GetNextValidPos(seq1, 0, hashLength, 0);
  while (pos < (seq1.length - hashLength) ) {
    tuple = trans_seq(seq1, pos, hashLength);
    findNode(table,  node, tuple, hashLength, wordLength);
    // Must at least find this node.
    assert(node != NULL);
    isUnique = node->IsUnique();
    numNeighbors = 0;
    if (!isUnique) {
      if (pos == seq1.length - hashLength - 1) 
	numNeighbors = search_to_k(node, numNeighbors, table, node->value, 
				   dist, hashLength, wordLength, neighboringTuple, 
				   seq1[pos+hashLength], doIndel);
      else
	numNeighbors = search_to_k(node, numNeighbors, table, node->value, 
				   dist, hashLength, wordLength, neighboringTuple, 
				   -1, doIndel);
    }
    if ( !isUnique || numNeighbors > 0) {
      seq1.MarkPosNotUnique(pos);
    }
    pos = GetNextValidPos(seq1, ++pos, hashLength, 0);
  }

  // Mask forward seq2 
  pos = GetNextValidPos(seq2, 0, hashLength, 0);
  while (pos < (seq2.length - hashLength+1)) {
    tuple = trans_seq(seq2, pos, hashLength);
    findNode(table, node, tuple, hashLength, wordLength);
    // Must at least find this node.
    assert(node != NULL);
    if ( !node->IsUnique() ) {
      seq2.MarkPosNotUnique(pos);
    }
    pos = GetNextValidPos(seq2, ++pos, hashLength, 0);
  }
  DeallocateTable(table, wordLength);
}

void AllocateTable(Node **&table, int wordLength) {
  int tableLength;
  tableLength = 1 << (2*(wordLength));
  table = new nodeptr[tableLength];
  int j;
  for (j = 0; j < tableLength; j++) { 
    table[j] = NULL;
  } 
}

void DeallocateTable(Node **&table, int wordLength) {
  // Deallocate all nodes in a table, and the table itself.
  int tableLength;
  tableLength = 1 << (2*(wordLength));
  int j;
  Node *node, *next;

  for (j = 0; j < tableLength; j++) { 
    node = table[j];
    while (node != NULL) {
      next = node->next;
      delete node;
      node = next;
    }
  } 
  delete []table;
}

void UnmaskShared(DNASequence &seq1,
		   DNASequence &seq2,
		   int hashLength, int wordLength) {

  // Mark positions that are shared between seq1 and seq2 as valid.
  // It is assumed that before processing this, all spots of seq1
  // and seq2 are marked as not shared if they are not already marked
  // as not unique or repeat masked.
  // It is up to this funciton to remove the not shared mask off of 
  // shared tuple positions.

  Node **table, *node;
  long startPos;
  AllocateTable(table, wordLength);
  StoreGenome(seq1, startPos, table, hashLength, wordLength);
  Tuple tuple;
  int pos;
  // Mask positions in sequence 2 that are not shared in position 1.
  pos = GetNextValidPos(seq2, 0, hashLength, 1);
  while (pos < (seq2.length - hashLength+1)) {
    // Make sure the current tuple is not masked
    if (!seq2.IsPosUniqueMasked(pos)) {
      // Find the current tuple in the other genome
      tuple = trans_seq(seq2, pos, hashLength);
      findNode(table, node, tuple, hashLength, wordLength);
      
      if ((node != NULL) && 
	  !(seq1.IsPosRepeatMasked(node->location)) &&
	  !(seq1.IsPosUniqueMasked(node->location))) {
	// Get rid of 
	seq1.UnmaskPos(node->location);
	seq2.UnmaskPos(pos);
      }
    }
    pos = GetNextValidPos(seq2, ++pos, hashLength, 1);
  }
  DeallocateTable(table, wordLength);
}


void EnumerateUnique(DNASequence &seq1, 
		     DNASequence &seq2, 
		     int hashLength, int wordLength,
		     int *permutedEnum,
		     int *permutedLocations) {
  int i, j;
  Node **referenceTable;
  // Allocate the table and the enumeration
  AllocateTable(referenceTable, wordLength);
  long tempStartPos = 0;

  // Create a hash of the reference genome
  StoreGenome(seq1, tempStartPos, referenceTable, 
	      hashLength, wordLength, 0);

  // Look for each 
  int pos, nodePos;
  int enumeration;
  Tuple tuple, rcTuple;
  Node  *node;
  // Mask forward seq2 

  enumeration  = seq2.startEnumeration;
  pos = GetNextValidPos(seq2, 0, hashLength, 1);
  while (pos < (seq2.length - hashLength+1)) {
    if (!seq2.IsPosUniqueMasked(pos) && !seq2.IsPosCommonMasked(pos)) {
      // This tuple is not unique masked, and is common, therefore
      // there will be an enumeration for it. 
      enumeration++;

      // Find the enumeration for this node in the enumeration array.
      tuple = trans_seq(seq2, pos, hashLength);
      // Find this node in the reference genome
      findNode(referenceTable, node, tuple, hashLength, wordLength);
      
      if ( node != NULL ) {
	// Found the tuple in the forward strand.
	assert("node is supposed to be unique but" &&  node->IsUnique() );
	if (! node->IsUnique() ) {
	  std::cout << "node should be unique " << std::endl;
	  exit(0);
	}
	nodePos = node->location;
	assert(!seq1.IsPosUniqueMasked(nodePos) 
		&& !seq1.IsPosCommonMasked(nodePos));
	// Node is not masked, assign it an enumeration
	assert("node should not have been enumerated yet " &&
	       node->enumeration == 0);
	// Store the result
	node->setEnumeration(enumeration);
	permutedEnum[node->location]      = enumeration;
	permutedLocations[node->location] = pos + seq2.startPosition;
      }
      else {
	rcTuple = ReverseComplement(tuple, hashLength);
	findNode(referenceTable, node, rcTuple, hashLength, wordLength);
	if (node != NULL) {
	  nodePos = node->location;
	  	  assert(!seq1.IsPosUniqueMasked(nodePos) 
		 && !seq1.IsPosCommonMasked(nodePos));

	  assert("node should not have been enumerated yet " &&
		 node->enumeration == 0);
	  // store the result
	  node->setEnumeration(-enumeration);
	  permutedEnum[node->location]     = -enumeration;
	  permutedLocations[node->location] = pos + seq2.startPosition;
	}
      }
    } // end if sequence is not masked
    // advance to the next ok pos
    pos = GetNextValidPos(seq2, ++pos, hashLength, 1);
  }
  DeallocateTable(referenceTable,wordLength);
}

void findNode(Node* table[],  Node *&node, Tuple tuple, int probe_len, int word_len) {
  Tuple hashVal = getHashValue(tuple, probe_len, word_len);
  node = table[hashVal];
  
  assert(tuple < (((Tuple)1)<<(probe_len*2)));
  while (node != NULL && node->value != tuple) {
    if (node == node->next) {
      std::cout << "While finding next found something wrong with the table structure, bailing out " << std::endl;
      exit(0);
    }
    node = node->next;
  }
}


void store(Node* table[], Tuple val, long pos, 
	   int probe_len, int word_len, int enumeration) {
  // Store a new tuple.  Each tuple is stored  as a node in a hash
  // table.  A list of the nodes that are unique is kept.  When a node
  // with a value that already exists in the hash table is being
  // stored, it is removed from the unique nodes list.
  
  // This is storing the reverse complement of a genome.  The
  // forward strand has already been stored, only store this tuple
  // if its reverse complement is present.
    
  Tuple hashVal = getHashValue(val, probe_len, word_len);
  Node* node = getNode(table[hashVal], val);
  
  if (node != NULL) {
    node->match = NULL;
  }
  else {
    // insert node at beginning of table, can speed up by making this sorted.
    // This is the newest node in this order, so it becomes the current node.
    Node* newNode = new Node(val, pos, table[hashVal]);
    if (newNode == NULL) {
      std::cout << "error storing a tuple, out of memory\n" << std::endl;
      exit(1);
    }
    table[hashVal] = newNode;
    newNode->setEnumeration(enumeration);
  }
}

Tuple getHashValue(Tuple val, int probe_len, int word_len) {
  Tuple res;
  if (probe_len > word_len)
    res = val >> (2*(probe_len- word_len));
  else
    res = val;
  return res;
}


Tuple trans_seq(DNASequence &seq, int pos, int len) {
  assert ((pos + len) <= seq.length);
  int i;
  Tuple res;
  char twoBitValue;
  res = 0;
  for (i = pos; i < len+pos; i++) {
    twoBitValue = DNASequence::Get2BitValue(seq.seq[i]);
    res = res*4 + twoBitValue;
  }
  return res;
}


Tuple trans_seq(char *seq, int len)
{
	int	i, j, k;
	Tuple	res;

	res = 0;
	for(i = 0; i < len; i ++)	{
		res = res * 4 + seq[i];
	}
	return(res);
}



void enumerateGenome(char *s, long l, long &enumeration, long &location, int
		     dir, Node *tableA[], Node* tableB[], int probe_len,
		     int word_len, int k, int doIndel) {
  long i = 0;
  if (l < probe_len) return;
  long nextBadNuc = -1;
  Tuple tup, rcTup;
  Node *node, *parent, *match, *rcNode;
  Tuple neighbor;
  for (i = 0; i < probe_len; i++) {
    if (s[i] > 3)
      nextBadNuc = i;
  }
  i = 0;
  int numNeighbors, numRefNeighbors;
  // store n-1 tuples, this allows for checking for deletions.
  // The last tuple is stored differently from all others, so don't store that in this loop
  while (i < (l-probe_len -1)) {
    if (s[i+probe_len-1] > 3 || s[i+probe_len-1] < 0) 
      nextBadNuc = i + probe_len-1;
    
    if (i > nextBadNuc) {
      tup = trans_seq(&s[i], probe_len);
      if (tup < 0) {
	int *crashme = 0; *crashme = 10;
      }
      findNode(tableA, node, tup, probe_len, word_len);


      // Since the reverse complement is symmetric, we can assign
      // it the same, but reversed enumeration.

      // at this point, if node->match is non-null, then the node is
      // unique in the genome, and not shared.
      //      if (node == NULL){
	// The node should exist in the table since it is in the genome, and no nodes are deleted.
	// EXCEPT, if the probability of not storing a tuple is > 0, then we can not find the node.
	//	  std::cout << "did not find node " << tup << "  "; printTuple(tup, probe_len, std::cout); 
	//	  std::cout << "in " << tableA << " at pos " << location <<  std::endl;
	//	  findNode(tableB, node, tup, probe_len, word_len);
	//	  std::cout << "its value in " << tableB << " is: " << node << std::endl;
	//	  std::cout << std::endl;
	//	  exit(1);
	//	continue;
	//      }

      if (node != NULL && node->match != NULL && node->match->match != NULL) {
	rcNode = NULL;
	rcTup = ReverseComplement(node->value, probe_len);
	findNode(tableA, rcNode, rcTup, probe_len, word_len);
	// Sanity check.
	if (rcNode == NULL) {
	  std::cout << "Asymmetric graph structure in enumerate "
		    << " genome " << std::endl;
	  std::cout << "asymmetry on " << i << " /" << l << " " ;
	  printTuple(tup, probe_len, std::cout); std::cout << " node: " << node << std::endl;
	  std::cout << "value of node: " << node->value << " rc: " << rcTup << std::endl;
	  exit(0);
	}


	// Make sure the node does not have any neighbors.
	search_to_k(node,  numRefNeighbors, tableA, node->value, 
		    k, probe_len, word_len, neighbor, s[i+1], doIndel);
	search_to_k(node->match, numNeighbors, tableB, node->value,    
		    k, probe_len, word_len, neighbor, s[i+1], doIndel);
	if (numRefNeighbors < 1 && numNeighbors < 1) {
	  // Node is unique, shared, and does not have any neighbors.
	  // Store it's location and enumeration.
	  //	  node->location    = location;
	  node->enumeration = enumeration ;

	  rcNode->enumeration = -enumeration;
          rcNode->match       = node;
	  enumeration++;
	}
	else {
	  // Record that this node is not unique by unlinking the match.
	  // DO NOT DELETE these nodes to save space, since they may be referenced later
	  // when searching for tuple-neighbors of deleted nodes.
	  node->match->match = NULL;
	  node->match = NULL;

	  // preserve symmetry
	  if (rcNode->match != NULL)
	    rcNode->match->match = NULL;
	  rcNode->match   = NULL;
	}
	if (enumeration % 10000 == 0) {
	  std::cout << "Assigned " << enumeration << " enumerations " 
		    << i <<  std::endl;
	}
      }
      else {
	// This node was invalid.  Recod that by not storing a match.
	if (node != NULL) node->match = NULL;
      }
    }
    i++;
    location ++;
  }
  // store last tuple.  There is no next nuc, so we signal that with -1.
  if (i > nextBadNuc){
    tup = trans_seq(&s[i], probe_len);
    // Find the tuple in the first genome.
    findNode(tableA, node, tup, probe_len, word_len);

    if (node != NULL && node->match != NULL) {
      // Since the reverse complement is symmetric, we can assign
      // it the same, but reversed enumeration.
      rcTup = ReverseComplement(node->value, probe_len);
      findNode(tableA, rcNode, rcTup, probe_len, word_len);
      // Sanity check.
      if (rcNode == NULL) {
	std::cout << "Asymmetric graph structure in enumerate "
		  << " genome " << std::endl;
	exit(0);
      }

      search_to_k(node,  numRefNeighbors, tableA, node->value, 
		  k, probe_len, word_len, neighbor, s[i+1], doIndel);
      search_to_k(node->match, numNeighbors, tableB, node->value,    
		  k, probe_len, word_len, neighbor, s[i+1], doIndel);
      if (numRefNeighbors < 1 && numNeighbors < 1) {
      // Node is unique, shared, and does not have any neighbors.
	// Store it's location and enumeration.
	node->location    = location ;
	node->enumeration = enumeration; //*dir;

	rcNode->enumeration = -enumeration;
	rcNode->match = node; 
	enumeration++; // += dir;
      }
      else {
	/* The tuple that corresponds to this node is not unique. */
	// Record that this node is not unique by unlinking the match.
	// DO NOT DELETE these nodes to save space, since they may be referenced later
	// when searching for tuple-neighbors of deleted nodes.
	node->match->match = NULL;
	node->match = NULL;
	if (rcNode->match != NULL)
	  rcNode->match->match = NULL;
	rcNode->match   = NULL;
      }
    }
  }
  location++; // increment for the last added nucleotide.
  location += probe_len;  // This didn't account for the probe location, do that now.
}


int  GetNextValidPos(DNASequence &seq, int pos, int tuple_len, int maskType) {
  // Search through seq for a sequence of length tuple_len that does not have 
  // any nucleotides masked as 'maskType'.
  // maskType has the following convention:
  //   0     Don't consider masking (only look at valid nucleotides).
  //   1     Repeat masked
  //   2     Unique masked
  //   4     Shared masked
  //   Any combination of mask consideration is used.
  int i;
  int valid = 0;
  
  int end = seq.length - tuple_len + 1;
  while (pos < end && ! valid) {
    // Check tuple at pos for validity
    i = 0;
    // assume the next tuple is ok
    valid = 1;
    // Search the length of the tuple or an error,
    // whichever comes first.  If the loop ends with i=tuple_len
    // then valid=1, and the whole while will stop.
    // if valid=0, then pos has been incremented, and the search 
    // will continue!

    while (i < tuple_len && valid ) {
      assert(pos < end);
      assert((pos+i) < seq.length);
      if (! seq.ValidNuc(seq.seq[pos+i], REPEAT_MASKED)) {
	// Invalid tuple at pos+i, continue looking at pos+i+1
	pos = pos+i+1;
	// Next tuple is not ok, break loop by sinaling it invalid.
	valid = 0;
      } // end if
      i++;
    }  // end while
  }
  return pos;
}


bool IsBadNuc(char nuc) {
  return (nuc > -5 && nuc < 4);
}

void StoreGenome(DNASequence &seq, long& startPos, Node* table[],
		 int hash_len, int word_len, int storerc, int enumeration) {
  // Store both the genome and reverse complement in a hash table.
  // Store the corresponding position and enumeration.
  long i = 0;
  if (seq.length < hash_len) return;
  long nextBadNuc = -1;
  Tuple tup, rc;
  i = 0;
  // store n-1 tuples, this allows for checking for deletions.nn
  for (i = 0; i < (seq.length - hash_len+1); i++ ) {
    if (seq.ValidSequence(i, hash_len, REPEAT_MASKED)) {
      tup = trans_seq(seq, i, hash_len);
      store(table, tup, i, hash_len, word_len, enumeration);
      
      if (storerc) {
	rc  = ReverseComplement(tup, hash_len);
	store(table, rc, i, hash_len, word_len, -enumeration);
      }
    }
  }
}



std::ostream& printTuple(Tuple tup, int tuple_size, std::ostream &out) {
  int i;
  Tuple mask = 3;  // 11 bin.
  char c;
  static char tuple2BitToNuc[] = {'G', 'A','C','T'};

  mask <<= (tuple_size -1)*2;
  for (i = 0; i < tuple_size; i++) {
    c = (tup & mask) >> ((tuple_size - i -1)*2);
    if (c >= 0 && c < 4) {
      out <<  tuple2BitToNuc[c];
    }
    else {
      std::cout << "error printing tuple " << tup  << " with value: " << (int) c << std::endl;
      exit(1);
    }
    mask >>=2;
  }
  return out;
}

int search_to_k(Node* result, int & numNeighbors, 
		Node* ref[], Tuple tuple, int k, int probe_len, 
		int word_len, Tuple &match, char next, int doIndel) {
  int i;
  numNeighbors = 0;
  for (i = k; i >= 0; i--) {
    search_k(result, numNeighbors, ref, tuple, i, probe_len, word_len, match, 0, next, doIndel);
  }
  return numNeighbors;
}


void search_k(Node* result, int & numNeighbors, Node* ref[], Tuple tuple, 
	      int k, int probe_len, int word_len, Tuple &match, int start, char next, int doIndel) {
  int pos;
  int mod;
  int nuc;
  Tuple neighbor;
  Node *node, *parent;
  if (k == 0) {
    // Simply look for this node.  The result is not a neighbor, so don't increment when finding one. 
    return;
  }
  if (k == 1) {
    // mutations, allow all possible positions.
    for (pos = start; pos < probe_len; pos++) {
      nuc = getNuc(tuple, pos, probe_len);
      for (mod = 1; mod < 4; mod++) {
	neighbor = snp(tuple, pos, (nuc + mod) % 4, probe_len);
	findNode(ref, result, neighbor, probe_len, word_len);
	if (result != NULL)
	  numNeighbors++;
      }
    }
    if (doIndel) {    // insertions, only insert in center.
      Tuple nextTup;
      if (next >= 0 && next <= 3)
	nextTup = del( (tuple << 2) + next, probe_len);
      else
	nextTup = -1;
      
      for (pos = start + 4; pos < (probe_len - 4); pos++) {
	for (mod = 0; mod < 4; mod++) {
	  neighbor = insert(tuple, pos, mod, probe_len);
	  if (neighbor > ( (1 << (probe_len*2))-1)) 
	    assert("neighbor is too large");
	  
	  if (neighbor != tuple  && neighbor != nextTup) {
	    findNode(ref, result, neighbor, probe_len, word_len);
	    if (result != NULL) {
	      numNeighbors++;
	    }
	  }
	}
      }
    
    // deletions, just look at center as well.
    if (next >= 0 && next < 4) 
      for (pos = start + 2; pos < (probe_len-2); pos++) {
	neighbor = del((tuple << 2) + next, pos);
      	if (neighbor != tuple  && neighbor != nextTup) {
	  findNode(ref, result, neighbor, probe_len, word_len);
	  if (result != NULL) {
	    numNeighbors++;
	  }
	}
      } 
    }
  }
  else if (k > 1) {
    for (pos = start; pos < probe_len - k + 1; pos++) {
      nuc = getNuc(tuple, pos, probe_len);
      for (mod = 1; mod < 4; mod++) {
	neighbor = snp(tuple, pos, (nuc + mod) % 4, probe_len);
	search_k(result, numNeighbors, ref, neighbor, k-1, probe_len, word_len, match, pos+1, next, doIndel);
      }
    }
  }
}


void printGenome(char *s,  long l, Node *reference[], Node *permuted[],
		 std::ostream &out, 
		 int probe_len, int word_len, int outputTuple) {
  long i = 1;
  if (l < probe_len) return;
  long nextBadNuc = -1;
  Tuple tup;
  Node *node, *parent, *match;
  for (i = 1; i <= probe_len; i++) {
    if (s[i] > 3)
      nextBadNuc = i;
  }
  i = 1;
  int nodeDir, matchDir;
  // store n-1 tuples, this allows for checking for deletions.
  while (i <= (l-probe_len)) {
    if (s[i+probe_len-1] > 3 || s[i+probe_len-1] < 0) 
      nextBadNuc = i + probe_len-1;
    if (i > nextBadNuc) {
      tup = trans_seq(&s[i], probe_len);
      findNode(reference, node, tup, probe_len, word_len);
      
      if (node != NULL && node->match != NULL) { 
	// Sanity check.  
	if (node->location < 0) {
	  std::cout << "for some reason found a node with negative dir looking forwards " 
		    << node->location << " " << i <<  std::endl;
	  exit(0);
	}

	// Found a match.  If it matches with the reverse complement (rc),
	// we would like to print the location of the rc tuple.  
	// The reason for this is that the original tuple was found to
	// match a rc by taking the rc of the compared strand, and
	// finding the original in it.  The copy of the rc strand has
	// increasing indices, whereas the indices of the rc-matching
	// strip should be in decreasing order.

	Node* matchLocation;

	if (node->match->enumeration < 0) {
	  // Found match in reverse strand.  Find the real location of
	  // the match by looking for the reverse in the forward
	  // strand.
	  Tuple rc = ReverseComplement(node->value, probe_len);
	  findNode(permuted, matchLocation, rc, probe_len, word_len);
	  // Sanity check
	  if (matchLocation == NULL ) { 
	    std::cout << "Asymmetric case where a tuple was present "
		      << "an unique, but its reverse complement was "
		      << "not. " << matchLocation  << std::endl;
	    exit(0);
	  }
	}
	else {
	  matchLocation = node->match;
	}
	  
	out  << node->enumeration  << "\t" << node->match->enumeration << "\t" ;
	out  << node->location << "\t"  << node->location << "\t" ;
	out  << matchLocation->location  << "\t"  
	     << matchLocation->location  << " 1 0"; 
	if (outputTuple) {
	  out << "\t";
	  printTuple(node->value, probe_len, out);
	}
	out << std::endl;
	if (node->enumeration % 100000 == 0) {
	  std::cout << "Printed " << node->enumeration << " enumerations " 
		    << std::endl;
	}
      }
    }
    i++;
  }
}


void PrintLocations(int *locations, int length, std::ostream &out) {
  int i;
  int len = 5;
  i = 0;
  out << std::setw(10) << std::setiosflags(std::ios::left) << i << ":";
  for (i = 0; i < length; i++) {
    out << std::setw(10) << std::setiosflags(std::ios::left) <<  locations[i];
    if (i % len == (len-1) && i < length-1) {
      out << std::endl;
      out << std::setw(10) << std::setiosflags(std::ios::left) << i +1 << ":";
    }
  }
  if (i % len != (len-1)) 
    out << std::endl;
}


void PrintCheckpoint(T_Alignment &alignment, T_Params &params, 
		     DNASequence &refSeq, DNASequence &qrySeq, 
		     std::string outFileName){
  std::ofstream out;
  out.open(outFileName.c_str(), std::ofstream::binary);
  out << params;
  BinaryPrintArray(alignment.locations, alignment.length, out);
  BinaryPrintArray(alignment.enumerations, alignment.length, out);
  out.write((char*) &alignment.hashLength, (std::streamsize) (sizeof(int)));
  BinaryPrintArray(refSeq.seq, refSeq.length, out);
  BinaryPrintArray(qrySeq.seq, qrySeq.length, out);
  out.close();
}


void ReadCheckpoint(T_Alignment &alignment, T_Params &params, 
		    DNASequence &refSeq, DNASequence &qrySeq,
		    std::string inFilename) {
  std::ifstream in;
  T_Params newParams;
  in.open(inFilename.c_str(), std::ifstream::in | std::ifstream::binary);
  in >> newParams;
  BinaryReadArray(alignment.locations, alignment.length, in);
  BinaryReadArray(alignment.enumerations, alignment.length, in);
  in.read((char*) &alignment.hashLength, (std::streamsize) (sizeof(int)));
  BinaryReadArray(refSeq.seq, refSeq.length, in);
  BinaryReadArray(qrySeq.seq, qrySeq.length, in);
}

