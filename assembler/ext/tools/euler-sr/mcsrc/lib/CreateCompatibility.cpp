/***************************************************************************
 * Title:          CreateCompatibility.cpp
 * Author:         Glenn Tesler
 * Created:        2009
 * Last modified:  03/02/2010
 *
 * Copyright (c) 2009-2010 The Regents of the University of California
 * All Rights Reserved
 * See file LICENSE for details.
 ***************************************************************************/

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <typeinfo>
#include <string.h>
#include "compatibility_template.h"

std::string format_int_type(const std::type_info &t, const std::string &suffix);
std::string format_size_type(const std::type_info &t, const std::string &suffix);
void configure_code();

void print_usage(int argc, char *argv[]) {
	std::string exe_name = "CreateCompatibility";
	if (argc >= 1) {
		exe_name = argv[0];
	}

	std::cerr << "usage: ";
	std::cerr << exe_name << " < compatibility_template.h > compatibility.h"
						<< std::endl;

	std::cerr << "  CreateCompatibility should be compiled with the same compiler and options" << std::endl;
	std::cerr << "  as the rest of the code.  It reads from STDIN and writes to STDOUT," << std::endl;
	std::cerr << "  replacing the line starting \"// --AUTOGEN--\" by several lines of" << std::endl;
	std::cerr << "  preprocessor directives." << std::endl;
}



int main(int argc, char *argv[]) {
	if (argc>1) {
		print_usage(argc,argv);
		exit(0);
	}

	int got_autogen = 0;



	std::cout << "// Do not edit this file! It is automatically generated. Changes will be lost." << std::endl;
	std::cout << "// Make changes in compatibility_template.h or CreateCompatibility.cpp." << std::endl;

	std::string line;

	while (std::getline(std::cin, line)) {
		std::cout << line << std::endl;
		if (line.compare(0,14,"// --AUTOGEN--") == 0) {
			got_autogen++;
			if (got_autogen>1) {
				print_usage(argc,argv);
				exit(0);

			}
			configure_code();
		}
	}

	if (got_autogen == 0) {
		print_usage(argc,argv);
	}

	exit(0);
}

void configure_code() {

	if (typeid(ssize_t) == typeid(int)) {
		std::cout << "#define _SIZET_IS_INT_" << std::endl;
	} else if (typeid(ssize_t) == typeid(long)) {
		std::cout << "#define _SIZET_IS_LONG_" << std::endl;
	} else {
		std::cerr << "WARNING: Cannot ascertain type of ssize_t.  Please notify the developers." << std::endl;
		std::cout << "#define _SIZET_IS_LONG_" << std::endl;
	}

	std::string fmt_pid = format_int_type(typeid(pid_t),"");
	if (fmt_pid == "") {
		std::cerr << "WARNING: Cannot ascertain type of pid_t.  Please notify the developers." << std::endl;
		fmt_pid = "%d";
	}
	std::cout << "#define PRI_PID \"" << fmt_pid << "\"" << std::endl;

	std::string fmt_size_t = format_size_type(typeid(size_t),"u");
	if (fmt_size_t == "") {
		std::cerr << "WARNING: Cannot ascertain type of size_t.  Please notify the developers." << std::endl;
		fmt_size_t = "%u";
	}
	std::cout << "#define PRI_SZT \"" << fmt_size_t << "\"" << std::endl;

	std::string fmt_ssize_t = format_size_type(typeid(ssize_t),"d");
	if (fmt_ssize_t == "") {
		std::cerr << "WARNING: Cannot ascertain type of ssize_t.  Please notify the developers." << std::endl;
		fmt_ssize_t = "%d";
	}
	std::cout << "#define PRI_SSZT \"" << fmt_ssize_t << "\"" << std::endl;

	if (sizeof(LongTupleWord) < sizeof(size_t)) {
		std::cout << "#define LongTupleWord_less_size_t\n";
	} else {
		std::cout << "#undef LongTupleWord_less_size_t\n";
	}

}


// Determine printf format specifier for an integer type.
// May need to add more to the list below.
//    t: typeid(...)
//    suffix: one of "d", "u", "i", "o", "x"
//            OR "" and it will figure out "d" or "u"
std::string format_int_type(const std::type_info &t, const std::string &suffix) {
	std::string suffix_s = (suffix == "" ? "d" : suffix);
	std::string suffix_u = (suffix == "" ? "u" : suffix);
	if (t == typeid(int)) {
		return "%" + suffix_s;
	} else if (t == typeid(unsigned int)) {
		return "%" + suffix_u;
	} else if (t == typeid(long)) {
		return "%l" + suffix_s;
	} else if (t == typeid(unsigned long)) {
		return "%l" + suffix_u;
	} else if (t == typeid(long long)) {
		return "%ll" + suffix_s;
	} else if (t == typeid(unsigned long long)) {
		return "%ll" + suffix_u;
	} else if (t == typeid(short)) {
		return "%h" + suffix_s;
	} else if (t == typeid(unsigned short)) {
		return "%h" + suffix_u;
	} else if (t == typeid(char)) {
		return "%hh" + suffix_s;
	} else if (t == typeid(unsigned char)) {
		return "%hh" + suffix_u;
	}
	return  "";
}

// Determine printf format specifier for size_t or ssize_t, only.
std::string format_size_type(const std::type_info &t, const std::string &suffix) {
	std::string suffix_s = (suffix == "" ? "d" : suffix);
	std::string suffix_u = (suffix == "" ? "u" : suffix);

	if (t != typeid(ssize_t) && t != typeid(size_t)) {
		std::cerr << "WARNING: Type is not size_t or ssize_t.  Please notify the developers." << std::endl;
		return format_int_type(t, suffix);
	}

	char buf[10];
	sprintf(buf,"%zd",ssize_t(5));
	if (!strcmp(buf,"5")) {
		// platform recognizes "z" modifier
		if (t == typeid(ssize_t)) {
			return "%z" + suffix_s;
		} else {
			return "%z" + suffix_u;
		}
	} else {
		// platform doesn't recognize "z" modifier
		return format_int_type(t, suffix);
	}
}
