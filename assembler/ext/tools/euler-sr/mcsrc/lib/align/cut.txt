float LocalAlign(DNASequence &seqa, DNASequence &seqb, 
		 float match, float mismatch, float gap, 
		 int *&locations, float **scoreMat) {
  init(match, mismatch);
  if (locations == NULL) {
    locations = new int[seqa.length];
  }
  int rows = seqa.length + 1;
  int cols = seqb.length + 1;
  // Create the score and path arrays
  float **score = CreateMatrix<float>(rows, cols);
  int   **path  = CreateMatrix<int>(rows, cols);
  int i, j;

  // Initialize gaps.
  for (i = 0; i < rows; i++) {
    score[i][0] = 0;
    path[i][0]  = GAP_A;
  }

  for (i = 0; i < cols; i++) {
    score[0][i] = 0;
    path[0][i] = GAP_B;
  }
  
  int r, c;
  int ind1, ind2;
  float gapA, gapB, mut;
  float minScore;
  float globalMinScore;
  int   globalMinCol, globalMinRow;
  globalMinScore= 0;
  globalMinRow  = 0;
  globalMinCol  = 0;
  for (r =1; r < rows; r++) {
    for (c = 1; c < cols; c++) {
      ind1 = (int) seqa.seq[r-1];
      ind2 = (int) seqb.seq[c-1];
      ind1 = nuc_index[(unsigned char)ind1];
      ind2 = nuc_index[(unsigned char)ind2];
      mut  = score[r-1][c-1] + score_mat[ind1][ind2];
      gapA = score[r-1][c] + gap;
      gapB = score[r][c-1] + gap;
      minScore = std::min((float)0.0, std::min(mut, std::min(gapA, gapB)));
      if (minScore == mut) {
	score[r][c] = mut;
	path[r][c]  = MATCH;
      }
      else if (minScore == gapA) {
	score[r][c] = gapA;
	path[r][c]  = GAP_A;
      }
      else if (minScore == gapB) { 
	score[r][c] = gapB;
	path[r][c] = GAP_B;
      } 
      else {
	score[r][c] = 0;
	path[r][c]  = LOCAL_START;
      }
      if (minScore < globalMinScore) {
	globalMinScore = minScore;
	globalMinCol = c;
	globalMinRow = r;
      }
    }
  }
  for (r = 0; r < seqa.length; r++) {
    locations[r] = -1;
  }

  std::cout <<"global min: " << globalMinRow << " " << globalMinCol << std::endl;

  GetAlignedLocations(path, (int**)NULL, (int**)NULL, 
		      rows, cols, 
		      locations, 1, globalMinRow, globalMinCol);

  minScore = score[globalMinRow][globalMinCol];
  DeleteMatrix(score, rows);
  DeleteMatrix(path, rows);
  return minScore;
}
