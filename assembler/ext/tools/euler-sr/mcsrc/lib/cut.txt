StripGen.

  

void PQPrintEnumerations(TreeStrip *head, std::ofstream & out) {
  //  std::priority_queue<TreeStrip*, std::list<TreeStrip*> > pqueue;
  // Print the enumerations in the order of the reference string.
  // This is done by placing all items on the tree on a priority queue
  // prioritized by reference string enumeration. 
  std::priority_queue<TreeStrip > pqueue;
  long curEnum = 0;
  if (head != NULL)
    AddStripsToPQueue(head, pqueue);
  
  TreeStrip temp;
  while (pqueue.size() > 0) {
    temp = pqueue.top();
    pqueue.pop();
    out << curEnum++ << "\t" << temp.enumValue << "\t" << temp.startRefPos 
	<< "\t" << temp.endRefPos << "\t" << temp.startQryPos << "\t" 
	<< temp.endQryPos << "\t" << temp.size << "\t" << temp.numMerged << "\t" << std::endl;
    }
}

void AddStripsToPQueue(TreeStrip *head, 
		       std::priority_queue<TreeStrip> &pqueue) {
  pqueue.push(*head);
  if (head->leftChild != NULL) 
    AddStripsToPQueue(head->leftChild, pqueue);
  if (head->rightChild != NULL) 
    AddStripsToPQueue(head->rightChild, pqueue);
}

TreeStrip * BuildStripRelations(T_Strips strips) {
  // BuildStripRelations determines the order of the strips by
  // building a binary tree 
  long l;
  TreeStrip *head = NULL;
  T_Strips::iterator it, end = strips.end();
  for (it = strips.begin(); it != end; ++it)
    Insert(head, *it);
  return head;
}



void Insert(TreeStrip *&head, Strip newStrip) {
  //  std::cout << "looking up range: " << newStrip.startQryEnum << " ... " << newStrip.endQryEnum << std::endl;
  if (head == NULL) {
    head = (TreeStrip*) new TreeStrip;
    head->startQryEnum = newStrip.startQryEnum;
    head->endQryEnum   = newStrip.endQryEnum;
    head->startRefPos  = newStrip.startRefPos;
    head->endRefPos    = newStrip.endRefPos;
    head->startQryPos  = newStrip.startQryPos;
    head->endQryPos    = newStrip.endQryPos;
    head->numMerged    = newStrip.numMerged;
    head->startRefEnum = newStrip.startRefEnum;
    head->endRefEnum   = newStrip.endRefEnum;
    head->size         = newStrip.size;
    head->sign         = newStrip.sign;
    totalInserts++;
    //std::cout << "inserting range: " << head->startQryEnum << " ... " << head->endQryEnum << std::endl;
  }
  else {
    totalCalls++;

    if (head->startQryPos > newStrip.endQryPos) 
      Insert( head->leftChild, newStrip); 
    else if (head->endQryPos < newStrip.startQryPos) 
      Insert( head->rightChild, newStrip);
    else {
      std::cout << "cannot build tree " << std::endl;
      exit(0);
    }
  }
}

void BFSPrintEnumerations(TreeStrip *head, std::ofstream &out) {
  Squeue queue;
  long curEnum = 1;
  queue.push(head);
  while (queue.size() > 0) {
    head = queue.front();
    queue.pop();
    out << curEnum++ << " " << head->enumValue << " " << head->startRefPos 
	<< " " << head->endRefPos << " " << head->startQryPos << " " 
	<< head->endQryPos << " " << head->size << " " << head->sign << std::endl;
    if (head->leftChild != NULL) 
      queue.push(head->leftChild);

    if (head->rightChild != NULL) 
      queue.push(head->rightChild); 
  }
}


void DFSAssignEnumerations(TreeStrip *head) {
  std::stack<TreeStrip*> stack;
  TreeStrip *curNode;
    long e = 1;
    if (head != NULL)
      stack.push(head);
    while (stack.size() > 0) {
      curNode = stack.top();
      if (curNode->leftChild != NULL && !curNode->leftChild->EnumerationAssigned()) {
	stack.push(curNode->leftChild);
	continue;
      }
      if (!curNode->EnumerationAssigned()) {
	curNode->enumValue = e++ * curNode->sign;
	//	std::cout << "assigning enum value " << e*curNode->sign << " to " << curNode->startQryEnum << " ... " << curNode->endQryEnum << std::endl;
      }
      if (curNode->rightChild != NULL && !curNode->rightChild->EnumerationAssigned()) {
	stack.push(curNode->rightChild);
	continue;
      }
      stack.pop();
    }
}

int GetLineOrig(std::ifstream &in,  long &curEnumRef, long &curEnumQry, long &curPosRef, long &curPosQry, int withSeq) {
  char seq[1000];
  int numNeighbors;
  if (withSeq)
    in >> curEnumRef >> curEnumQry >> curPosRef >> curPosQry >> numNeighbors >> seq;
  else 
    in >> curEnumRef >> curEnumQry >> curPosRef >> curPosQry >> numNeighbors;
  return ! in.eof();
}

int GetLineSigned(std::ifstream &in, long &enumRef, long &enumQry, 
		long &startPosRef, long &endPosRef, 
		long &startPosQry, long &endPosQry, long & size, int& numMerged, int &sign) {
  in >> enumRef >> enumQry >> startPosRef >> endPosRef >> startPosQry >> endPosQry >> size >> numMerged ;
  if (enumQry)
    sign = enumQry / labs(enumQry);
  // Modify this to deal with increasing negative strip enumerations.
  //  enumQry = labs(enumQry);
  return ! in.eof();
}

int GetLineUnsigned(std::ifstream &in, long &enumRef, long &enumQry, 
		long &startPosRef, long &endPosRef, 
		long &startPosQry, long &endPosQry, long & size, int& numMerged) {
  in >> enumRef >> enumQry >> startPosRef >> endPosRef >> startPosQry >> endPosQry >> size >> numMerged;
  return ! in.eof();
}

int GetLineSecond(std::ifstream &in, long &enumRef, long &enumQry, 
		long &startPosRef, long &endPosRef, 
		long &startPosQry, long &endPosQry, long & size, int& numMerged) {
  in >> enumRef >> enumQry >> startPosRef >> endPosRef >> startPosQry >> endPosQry >> size >> numMerged;
  return ! in.eof();
}

