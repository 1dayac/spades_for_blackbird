#include "IntervalGraph.h"
#include "PathLib.h"
#include "MateLibrary.h"



void PrintUsage() {
	std::cout << "usage: mateTransformGraph graphName vertexSize "
						<< "mateTableName ruleFileName graphOutName matePathSeqName " << std::endl
						<< "      [-minMatePairCount m]" << std::endl
						<< "      [-notStrict]" << std::endl;
	std::cout << "      [-noIter]  Do not iteratively simplify paths." << std::endl;
}

int main(int argc, char* argv[]) {
	std::string graphFileName, graphOutName;
	int vertexSize;
	if (argc < 7) {
		PrintUsage();
		exit(0);
	}
	std::string mateTableName, ruleFileName;
	std::string matePathSeqName;

	graphFileName   = argv[1];
	vertexSize      = atoi(argv[2]);
	mateTableName   = argv[3];
	ruleFileName    = argv[4];
	graphOutName    = argv[5];
	matePathSeqName = argv[6];
	int argi = 7;
	int minMatePairCount = 3;
	int notStrict = 0;
	int verbose = 1; // default to verbose for now.
	int iterate = 1;
	while (argi < argc) {
		if (strcmp(argv[argi], "-minMatePairCount") == 0) {
			minMatePairCount = atoi(argv[++argi]);
		}
		else if (strcmp(argv[argi], "-notStrict") == 0) {
			notStrict = 1;
		}
		else if (strcmp(argv[argi], "-verbose") == 0) {
			verbose = !verbose;
		}
		else if (strcmp(argv[argi], "-noIter") == 0) {
			iterate = 0;
		}
		else {
			PrintUsage();
			std::cout << "bad option: " << argv[argi] << std::endl;
			exit(1);
		}
		++argi;
	}
		
	EdgePairMap pairedEdgeMap;
	
	IntervalGraph graph;
	ReadIntervalGraph(graphFileName, graph, vertexSize);


	RuleList rules;
	ParseRuleFile(ruleFileName, rules);

	ReadMateList mateList;
	ReadMateTable(mateTableName, mateList);


	PathIntervalList &paths       = graph.paths;
	PathLengthList   &pathLengths = graph.pathLengths;
	TEdgeList        &edges       = graph.edges;
	TVertexList      &vertices    = graph.vertices;

	// Go from the mate paths to regular paths.

	int p, readIndex;
	PathBranch pathTree;
	
	// Compute some statistics on the number of mate-pairs spanning 
	// each pair of edges.
	int mateType, mateIndex, lastPathIntv, 
		lastEdge,	lastEdgeIntv,	lastEdgePos;

	int graphIsTransformed;
	int detachIter = 0;
	do {

		graphIsTransformed = 0;
		// Remove mate-pairs that are too low in frequency (perhaps remove the reads as well)

		// Count the mate pais on every edge, and store their average position.
		StoreEdgePairMap(graph, mateList, pairedEdgeMap);

		// If two edges are joined by mate pairs less than minMatePairCount
		// get rid of the mate pairings.
		RemoveLowFrequencyEdgePairs(graph, pairedEdgeMap, mateList, minMatePairCount);
		
		// Search for paths between mates, when a single path exists, store it.
		StoreMatePaths(graph, vertices, edges, rules, pairedEdgeMap, pathTree);

		//		if (detachIter > 0) {
		if (0) {
			// When not on the first iteration, attempt to resolve mate-paths
			// by condensing ambiguous repeats.
			EdgePairMap::iterator epIt, epEnd;
			std::vector<int> edgeOnPathCount, pathVect;
			edgeOnPathCount.resize(edges.size());
			// Initialize the counts to 0.
			std::fill(edgeOnPathCount.begin(), edgeOnPathCount.end(), 0);

			std::vector<int> edgeTraversalCount;
			edgeTraversalCount.resize(edges.size());
			// Mark all edges that are on part of a putative mate-path.
			for (epIt = pairedEdgeMap.begin(),
						 epEnd = pairedEdgeMap.end(); epIt != epEnd; ++epIt) {
				if ((*epIt).second.numPaths > 1) {
					pathVect.resize(rules[(*epIt).first.mateType].cloneLength + 
													rules[(*epIt).first.mateType].cloneVar);
					std::fill(pathVect.begin(), pathVect.end(), -1);
					int numPaths = 0;
					int totalLength = 0;
					int totalEdges = 0;
					MarkEdgesOnValidMatePaths(graph, (*epIt).first.edge1, (*epIt).second.meanEdge1End,
																		(*epIt).first.edge2, (*epIt).second.meanEdge2Start,
																		0, 
																		rules[(*epIt).first.mateType].cloneLength -
																		rules[(*epIt).first.mateType].cloneVar,
																		rules[(*epIt).first.mateType].cloneLength +
																		rules[(*epIt).first.mateType].cloneVar,
																		30, pathVect, 0, edgeOnPathCount, 
																		numPaths, totalLength, totalEdges, edgeTraversalCount);
					int averageLength = 0;
					int averageNumEdges = 0;
					if (numPaths > 0) {
						averageLength = (int) (totalLength * 1.0/numPaths);
						averageNumEdges = totalEdges / numPaths;
					}
					(*epIt).second.averageNumEdges = averageNumEdges;
					(*epIt).second.numPaths = numPaths;
					
					std::cout << (*epIt).first.edge1 << " " << (*epIt).first.edge2 << " " 
										<< (*epIt).second.numPaths << " " << numPaths << " " 
										<< averageLength << " "
										<< (*epIt).second.averageNumEdges << std::endl;
					/*
						int v;
						for (v =0 ; v < pathVect.size() and pathVect[v] != -1; v++ ){
						std::cout << pathVect[v] << " ";
					}
					std::cout << std::endl;
					*/
				}
			}
			
			std::vector<std::pair<int, MatePairMap*> > orderedEdgePairIndex;
			orderedEdgePairIndex.resize(pairedEdgeMap.size());
			int i = 0;
			for (epIt = pairedEdgeMap.begin(); epIt != epEnd; ++epIt) {
				orderedEdgePairIndex[i].first = (*epIt).second.averageNumEdges;
				orderedEdgePairIndex[i].second = &(*epIt).second;
				i++;
			}
			std::sort(orderedEdgePairIndex.begin(),
								orderedEdgePairIndex.end());
			for (i = 0; i < orderedEdgePairIndex.size(); i++) {
				std::cout << i << " " << orderedEdgePairIndex[i].second->edge1 << " " 
									<< orderedEdgePairIndex[i].second->edge2 << " " 
									<< orderedEdgePairIndex[i].second->averageNumEdges << std::endl;
			}
		}
		

		// Collect the paths due to mate-pairs.
		PathTraceList mateTraces;
		PathTreeToPathList(pathTree, mateTraces);

		// Collect the paths due to reads so that mate transformations
		// are consistent with read paths.
		CollectPathTree(paths, pathLengths, pathTree);
		//	PrintPathTree(pathTree);

		std::cout << "Done collecting paths.  Looking for redundant paths." << std::endl;
		// Make the list of paths more easy to search.
		PathTraceList pathTraces;
		PathTreeToPathList(pathTree, pathTraces);

		// Find paths that are subpaths of others.
		MarkEnclosedPaths(pathTraces);
		RemoveEnclosedPaths(pathTraces);
	
		TraceMapMatrix traceMaps;
		traceMaps.resize(edges.size());
		StoreTraceMaps(pathTraces, traceMaps);

		PrintCandidatePaths(pathTraces, traceMaps, edges);

		MarkResolvedPaths(pathTraces, traceMaps, notStrict);

		PrintTracesAsReads(vertices, edges, pathTraces, matePathSeqName);

		// Print some useful information about the paths
		if (verbose) PrintPathTraceResolution(edges, pathTraces, traceMaps);

		// Make sure each path has it's own balance, but don't bother 
		// doing this in optimized mode.
		assert(CheckPathBalance(edges, pathTraces, traceMaps));


		// Store the balanced edge of all paths.  This is necessary 
		// in order to update balance while the graph is being modified.
		std::vector<int> balancedEdges;
		balancedEdges.resize(edges.size());
		int e;
		for (e = 0; e < edges.size(); e++) {
			balancedEdges[e] = edges[e].balancedEdge;
		}

		// Just for some bookkeeping and stats later on.
		std::set<int> internalDetachedEdges;
		// Now fix the balance of the paths.
		for (p = 0; p < pathTraces.size(); p++ ) {
			int firstEdge = (*pathTraces[p].edges)[0];
			int traceLength = pathTraces[p].edges->size();
			int lastEdge = (*pathTraces[p].edges)[traceLength -1];
			int balancedEdge = balancedEdges[lastEdge];
			int balancedLastEdge = balancedEdges[firstEdge];

			if (traceMaps[firstEdge].outResolved and traceMaps[lastEdge].inResolved) {
				
				std::cout << "detaching path: " << p << " ";
				int pi;
				for (pi = 0; pi < pathTraces[p].edges->size(); pi++) {
					std::cout << (*pathTraces[p].edges)[pi] << " ";
				}
				std::cout << std::endl;
				DetachPath(pathTraces, traceMaps, graph, vertices, edges,
									 paths, pathLengths,
									 pathTraces[p], p, mateList, 0);
			
				graphIsTransformed = 1;
				traceMaps[firstEdge].outResolved = 0;
				traceMaps[lastEdge].inResolved = 0;
				for (pi = 1; pi < pathTraces[p].edges->size() - 1; pi++) {
					internalDetachedEdges.insert((*pathTraces[p].edges)[pi]);
				}
			
				int lastEdgeBal, firstEdgeBal;
				lastEdgeBal = balancedEdges[lastEdge];
				firstEdgeBal = balancedEdges[firstEdge];
				assert(traceMaps[lastEdgeBal].outResolved);
			
				int balPathTraceIndex = traceMaps[lastEdgeBal].GetFirstStartTraceIndex();
				int balPathTrace = traceMaps[lastEdgeBal].traces[balPathTraceIndex].trace;
				std::cout << " detaching balanced path. " << balPathTrace << " ";
				for (pi = 0; pi < pathTraces[balPathTrace].edges->size(); pi++) {
					std::cout << (*pathTraces[balPathTrace].edges)[pi] << " ";
				}
				std::cout << std::endl;
				DetachPath(pathTraces, traceMaps, graph, vertices, edges,
									 paths, pathLengths, 
									 pathTraces[balPathTrace], balPathTrace, mateList, 0);

				for (pi = 1; pi < pathTraces[balPathTrace].edges->size() - 1; pi++) {
					internalDetachedEdges.insert((*pathTraces[balPathTrace].edges)[pi]);
				}
				traceMaps[lastEdgeBal].outResolved = 0;
				traceMaps[firstEdgeBal].inResolved = 0;
			}
		}
		int ed = 237;
		std::cout << "edge :" << ed << std::endl;
		int pi;
		for (pi = 0; pi < (*edges[ed].intervals).size(); pi++) {
			std::cout << (*edges[ed].intervals)[pi].edge << " "  
								<< (*edges[ed].intervals)[pi].edgePos << " " 
								<< (*edges[ed].intervals)[pi].length << " " 
								<< (*edges[ed].intervals)[pi].markedForDeletion << std::endl;
		}
		ed = 974;
		std::cout << "edge :" << ed << std::endl;
		for (pi = 0; pi < (*edges[ed].intervals).size(); pi++) {
			std::cout << (*edges[ed].intervals)[pi].edge << " "  
								<< (*edges[ed].intervals)[pi].edgePos << " " 
								<< (*edges[ed].intervals)[pi].length << " " 
								<< (*edges[ed].intervals)[pi].markedForDeletion << std::endl;
		}
			
		// All of the internal edges should have been cleared.  Check out
		// how many weren't.
		std::set<int>::iterator setIt, setEnd;
		setEnd = internalDetachedEdges.end();
		for (setIt = internalDetachedEdges.begin(); setIt != setEnd; ++setIt) {
			std::cout << *setIt << " " << edges[*setIt].intervals->size() << " " << edges[*setIt].length << std::endl;
			int balEdge = balancedEdges[*setIt];
			if (internalDetachedEdges.find(balEdge) == internalDetachedEdges.end()) {
				std::cout << "edge: " << *setIt << " is detached, but not balance: " << balEdge << std::endl;
				exit(1);
			}
		}
	
		graph.RemoveMarkedIntervalsNoPaths();
		graph.RemoveEmptyEdges();
		int nremoved = graph.RemoveEmptyVertices();
		std::cout << "removed: " << nremoved << " vertices." << std::endl;
		graph.CondenseSimplePaths();

		// Free the allocated structures.
		for (p = 0; p < pathTraces.size(); p++) {
			if (pathTraces[p].edges != NULL) {
				pathTraces[p].edges->clear();
				delete pathTraces[p].edges;
			}
			pathTraces[p].edges = NULL;
		}
		pathTraces.clear();
		int m;
		for (m = 0; m < mateTraces.size(); m++ ){
			if (mateTraces[m].edges != NULL) {
				mateTraces[m].edges->clear();
				delete mateTraces[m].edges;
			}
			mateTraces[m].edges = NULL;
		}
		mateTraces.clear();

		traceMaps.clear();
		internalDetachedEdges.clear();
		balancedEdges.clear();
		pairedEdgeMap.clear();
		DeletePathTree(pathTree);
		++detachIter;
	}
	while (iterate && graphIsTransformed);
	int pi;

	std::string bGraphOutName = graphOutName + ".bgraph";
	std::string intvOutName = graphOutName + ".intv";
	std::string gvzOutName  = graphOutName + ".gvz";
	std::string pathOutName = graphOutName + ".path";
	std::string edgeOutName = graphOutName + ".edge";
	
	CheckEdges(graph.vertices, graph.edges);

	graph.PrintIntervalGraph(bGraphOutName, intvOutName);


  PrintGraph(graph.vertices,graph.edges, graphOutName);
  PrintEdges(graph.vertices, graph.edges, edgeOutName);
  GVZPrintBGraph(graph.vertices, graph.edges, gvzOutName);
	WriteReadPaths(pathOutName, graph.paths, graph.pathLengths);

	return 0;

}


