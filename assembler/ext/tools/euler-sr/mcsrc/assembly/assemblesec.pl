#!/usr/bin/env perl

############################################################################
# Title:          assemblesec.pl
# Author:         Mark Chaisson, Glenn Tesler
# Created:        2008
# Last modified:  03/04/2010
# 
# Copyright (c) 2008-2010 The Regents of the University of California
# All Rights Reserved
# See file LICENSE for details.
############################################################################

BEGIN {
		unshift(@INC, $ENV{"EUSRC"} . "/assembly/");
}

use RunCmd;

my $machtype = $ENV{"MACHTYPE"};
my $srcDir = $ENV{"EUSRC"};
my $exeDir = "$srcDir/assembly/$machtype";

if (!defined $srcDir || !defined $machtype) {
		print "ERROR: Need to define environment variables EUSRC and MACHTYPE\n";
		print_usage();
		exit(1);
}

$Usage::exeDir = $exeDir;

if ($#ARGV < 0) {
		print_usage();
		exit(0);
}

my $cmdLine = join " ", ($0, @ARGV);
my $vertexSize = 20;
my $readsFile = shift @ARGV;
my $curdir = "";
my $verbose = 0;
my $verboseOpt = ""; # for passing to commands that recognize it
my $forceLarge = 0;
my $earlyTrim = 0;
my $minCov = 0;
my $skipIntervals = 0;
my $script = 0;
my $useDebug = 0;
my $highCov = 0;


$minKmerCount = 1;
while ($#ARGV >= 0) {
  $option = shift @ARGV;
  if ($option eq "-vertexSize") {
			$vertexSize = shift @ARGV;
  }
  elsif ($option eq "-dir") {
			$curdir = shift @ARGV;
  }
	elsif ($option eq "-minKmerCount") {
			$minKmerCount = shift @ARGV;
	}
	elsif ($option eq "-verbose") {
			$verbose = 1;
			$verboseOpt = " -verbose";
	}
	elsif ($option eq "-forceLarge") {
			$forceLarge = 1;
	}
	elsif ($option eq "-earlyTrim") {
			$earlyTrim = 1;
	}
	elsif ($option eq "-minCov") {
			$minCov = shift @ARGV;
	}
	elsif ($option eq "-skipIntervals") {
			$skipIntervals = 1;
	}
	elsif ($option eq "-script") {
			$script = 1;
	}
	elsif ($option eq "-debug") {
			$useDebug = 1;
	}
	else {
			print "bad option: $option\n";
			print_usage();
			exit(1);
	}
}


#
# If the debug code is specified, change the directory for the executables.
#

if ($useDebug != 0) {
		$exeDir = $exeDir . "_debug";
		$Usage::exeDir = $exeDir;
}

###############################################################################
# Validate vertex size
###############################################################################

# Get maximum K allowed
my $maxK = 0;
my $runMaxK = "$exeDir/maxK";
if (defined $exeDir && -e $runMaxK && -x $runMaxK) {
    # TODO: probably should verify that all executables are available

    # WARNING:
    # Use RunCmd::RunCommandLog for all other system commands unless
    # there's a good reason.
		$maxK = int(`$runMaxK`);
}
if ($maxK == 0) {
		print <<"END_error";
ERROR: executable $runMaxK missing or not working.
Need to define environment variables EUSRC and MACHTYPE correctly,
and need to build EULER-SR before running this script.

END_error
		print_usage();
		exit(1);
}
if ($vertexSize > $maxK
		&& !$forceLarge) {
		print <<"END_error";
ERROR: EULER-SR has been compiled with a maximum vertex size $maxK.
To use a larger vertex size, we strongly recommend setting compilation
options for a larger maximum.  However, you may also run this script
with the '-forceLarge' option, which uses an alternate, less effficient,
set of code.

END_error
		print_usage();
		exit(1);
}


###############################################################################
# Set up various files
###############################################################################


if ($curdir != "") {
		if (!$script) {
				chdir($curdir);
		} else {
				print "cd $curdir\n";
		}
}

if (! -e $readsFile) {
		if (!$script) {
				print "$readsFile does not exist\n";
				exit(1);
		}
}

# Report file for fatal errors
$RunCmd::reportfile = "${readsFile}.report";
if ($RunCmd::reportfile =~ m|^fixed/(.*)$|) {
		$RunCmd::reportfile = $1;
}


# Option to generate a script instead of executing commands.
if ($script) {
		$verbose = -1;
		my $cmd = $cmdLine;
		$cmd =~ s/\s-script\s/ /g;
		$cmd =~ s/\s-script$/ /g;
		print <<"START_script";
#!/bin/sh
#
# Commands generated by assemblesec.pl with these options:
# $cmd

START_script
}


###############################################################################
# Generate commands to run the different parts of the assembly
###############################################################################

# create all the commands at the top of the script so 
# I don't have to look all over the place to find them

if ($vertexSize > $maxK || $forceLarge) {
		$buildVertexCmd = 
				"$exeDir/countSpectrum $readsFile $readsFile.v -tupleSize $vertexSize -printPos";
		$sortVertexCmd =
				"$exeDir/sortVertexList $readsFile.v $readsFile $vertexSize $readsFile.sv";

		# TODO: implement -earlyTrim and -minCov options for large k-mer case
		$buildGraphCmd = 
				"$exeDir/debruijn $readsFile $readsFile.sv $readsFile.dot -vertexSize $vertexSize";

		$printGraphVizCmd = "";

		$edgesToOverlapListCmd =
				"$exeDir/edgesToOverlapList $readsFile.edge $vertexSize $readsFile.ovp";
		$printReadIntervalsCmd =
				"$exeDir/printReadIntervals $readsFile.ovp $readsFile.edge $readsFile $vertexSize $readsFile.intv $readsFile.path";
}
else {
#### TEMP DISABLE MINMULT (rsmm0)
		$buildVertexCmd =
				"$exeDir/readsToSpectrum $readsFile $vertexSize $readsFile.spect -minMult $minKmerCount";

    $sortVertexCmd = 
				"$exeDir/sortIntegralTupleList $readsFile.spect -printCount";

		my $trimOpt = "";
		if ($earlyTrim) {
				my $trim = $vertexSize * 3;
				$trimOpt = "-trimShort $trim";
		}
#### TEMP DISABLE MINCOV (svmc0)
		$buildGraphCmd =
				"$exeDir/svdeBruijn $readsFile $vertexSize $trimOpt -minCov $minCov";

# temporarily disable
#		$printGraphVizCmd = "$exeDir/printComponentsToGVZ $readsFile";

		$edgesToOverlapListCmd = 
				"$exeDir/integralEdgesToOverlapList $readsFile.edge $vertexSize $readsFile.iovp";

		# TODO: Re-created, check that it's correct
		$printReadIntervalsCmd =
				"$exeDir/integralPrintReadIntervals $readsFile";
}


#$removeFilesCmd = "$srcDir/assembly/CleanUpIntermediates.pl $readsFile";

RunCmd::RunCommandLog($buildVertexCmd, "Building vertices", $verbose); #1

RunCmd::RunCommandLog($sortVertexCmd, "Sorting vertices", $verbose); #2

RunCmd::RunCommandLog($buildGraphCmd, "Building graph", $verbose); #3

if ($printGraphVizCmd) {
		RunCmd::RunCommandLog($printGraphVizCmd, "Printing initial graph to GraphViz", $verbose);
}


if (!$skipIntervals) {

		RunCmd::RunCommandLog($edgesToOverlapListCmd, "Mapping read intervals", $verbose); #4

    #
    #  This section is commented out so that it may be replaced
    # by a two step process where the graph is built and then simplified
    # and reads are mapped to the simplifed graph.
    #

		if (defined $printReadIntervalsCmd) {
				RunCmd::RunCommandLog($printReadIntervalsCmd, "Printing read intervals", $verbose); #5
		}
}

sub print_usage {

		my $exeDir = $Usage::exeDir;
		my $runMaxK = "$exeDir/maxK";
		my $maxK = 0;
		if (defined $exeDir && -e $runMaxK && -x $runMaxK) {
				# WARNING:
				# Use RunCmd::RunCommandLog for all other system commands unless
				# there's a good reason.
				$maxK = int(`$runMaxK`);
		}
		if (!$maxK) {
				$maxK = "[NOT AVAILABLE]";
		}

		print <<"END_usage";
usage: assemblesec.pl readsFile [options]
This is intended to be run by other scripts, not directly by the user.

   [-vertexSize v]

   [-minKmerCount m]

   [-minCov c]       Minimum coverage to keep an edge.
                     Used in small vertex de Bruijn construction.

   [-earlyTrim]      Trim short edges of coverage 1.

   [-skipIntervals]  Skip outputting interval file at end.
                     The file is not needed when -useAltEdges is used.

   [-exeDir e]

TROUBLESHOOTING OPTIONS:

   [-script]         Do not execute commands.  Instead, output a
                     script that would execute the commands.

   [-verbose]        Show output from subprocesses.
                     Output is suppressed without this option.

   [-debug]          Run the debug version of the code, compiled by
                     'make debug'.

   [-forceLarge]     EULER has been compiled to handle vertex size <= ${maxK}.
                     It can be configured at compile-time to handle larger
                     vertex size, and we strongly recommend doing this
                     if you need a larger size.

                     Previously, EULER used different programs for
                     small vertex size vs. large vertex size.  To run
                     the old programs for large vertex size, use '-forceLarge'.

assembleSEC: assembly Sans Error Correction.  A quick way of binning reads.
This simply builds a de bruijn graph on raw reads, and does not process it
further.  For certain applications, this is sufficient, but for most de novo
assemblies, this will not assemble any meaningful contigs.
END_usage
}
