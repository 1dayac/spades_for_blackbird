/***************************************************************************
 * Title:          IntervalGraph.cpp 
 * Author:         Mark Chaisson
 * Created:        2007
 * Last modified:  2007
 *
 * Copyright (c) 2007-2008 The Regents of the University of California
 * All Rights Reserved
 * See file LICENSE for details.
 ***************************************************************************/
#include "HashedSpectrum.h"
#include "IntervalGraph.h"
#include "DeBruijnGraph.h"
#include "graph/GraphAlgo.h"
#include "graph/MSTAlgo.h"
#include "Spectrum.h"
#include <iomanip>
#include <algorithm>



void FormGraphFileNames(std::string &base, 
												std::string &bgraph, std::string &graph,
												std::string &intv, 
												std::string &path, std::string &edge) {
	bgraph = base + ".bgraph";
	graph  = base + ".graph";
	intv   = base + ".intv";
	path   = base + ".path";
	edge   = base + ".edge";
}

void ReadIntervalGraph(std::string &baseIn, 
											 IntervalGraph &graph, int vertexSize, int skipIntervals) {

	std::string bGraphFileName, graphFileName,
		intervalFileName, pathFileName, edgeFileName;

	FormGraphFileNames(baseIn, bGraphFileName, graphFileName,
										 intervalFileName, pathFileName, edgeFileName);

	graph.vertexSize    = vertexSize;

	graph.ReadIntervalGraph(bGraphFileName, intervalFileName, pathFileName, skipIntervals);

	ReadSequences(edgeFileName, graph.edges);
}

void WriteIntervalGraph(std::string &baseOut,
												IntervalGraph &graph, int vertexSize) {

	std::string bGraphFileName, graphFileName,
		intervalFileName, pathFileName, edgeFileName;

	FormGraphFileNames(baseOut, bGraphFileName, graphFileName,
										 intervalFileName, pathFileName, edgeFileName);

	graph.PrintIntervalGraph(bGraphFileName, intervalFileName);

  PrintGraph(graph.vertices, graph.edges, graphFileName);
  PrintEdges(graph.vertices, graph.edges, edgeFileName);
	WriteReadPaths(pathFileName, graph.paths, graph.pathLengths);
}


void IntervalGraph::CalcDMST() {
  GraphAlgo::CalcDirectedMST(vertices, edges);
}


void IntervalGraph::PrintIntervalGraph(std::string &bGraphName,
																			 std::string &intervalName) {
	std::ofstream bGraphOut;
	openck(bGraphName, bGraphOut, std::ios::out);
  PrintBGraph(vertices, edges, bGraphOut);
	bGraphOut << vertexSize;
	SortAllEdgeIntervalsByEdgePos();
	PrintReadIntervals(edges, intervalName);
	SortAllEdgeIntervalsByReadPos();
} 

int IntervalGraph::CalculateReadLength(int read) {
  int pathPos;
	
  pathPos = 0;
  int readLength = 0;
  int edgeIndex;
  int intvIndex;
  int destVertex;
  for (pathPos = 0; pathPos < pathLengths[read]; pathPos++) {
    edgeIndex = paths[read][pathPos].edge;
    intvIndex = paths[read][pathPos].index;
    destVertex = edges[edgeIndex].dest;
    readLength+= (*edges[edgeIndex].intervals)[intvIndex].length - vertices[destVertex].vertexSize;
  }
  /* 
     The last interval goes upto and including the last vertex, so the loop
     over-subtracts by one vertex.  Add that back now.
  */
  readLength += vertices[destVertex].vertexSize;
  return readLength;
}

void IntervalGraph::CheckGraphStructureBalance() {
  int v, e;
  int destV, balV, balE;
  for (e = 0; e < edges.size(); e++) {
    destV = edges[e].dest;
    balE  = edges[e].balancedEdge;
    balV  = edges[balE].src;
    if (edges[balE].balancedEdge != e) {
      std::cout << "EDGE BALANCE ERROR: " << e << " != " << edges[balE].balancedEdge << std::endl;
    }
    else {
      if (destV >= 0 and 
					(vertices[destV].InDegree() != vertices[balV].OutDegree() or
					 vertices[destV].OutDegree() != vertices[balV].InDegree())) {
				std::cout << "Graph is not complementary. " << std::endl;
				std::cout << "vertex " << destV << " " << vertices[destV].InDegree() 
									<< " " << vertices[destV].OutDegree() << " versus: " << balV <<"  "
									<< vertices[balV].InDegree() << " "
									<< vertices[balV].OutDegree() << std::endl;
      }
    }
  }
}

void IntervalGraph::AssignPathOrderToEdges() {
  int p, e;
  for (p = 0; p < paths.size(); p++ ) {
    for (e = 0; e < pathLengths[p]; e++ ) {
			assert(paths[p][e].edge < edges.size());
			assert(paths[p][e].index < edges[paths[p][e].edge].intervals->size());
      (*edges[paths[p][e].edge].intervals)[paths[p][e].index].pathPos = e;
    }
  }
}
	
void IntervalGraph::CheckAllPathsBalance(int fatal) {
  int p, pos;
  int edge, intv, balEdge, balIntv;
  std::cout << "checking path balance " << std::endl;
  for (p = 0; p < paths.size(); p+=2 ) {
    int balp = p + 1;
    if (CheckPathBalance(p, balp) == 0) {
      PrintImbalancedPaths(p, balp);
      assert(!fatal);
    }
  }
}

void IntervalGraph::PrintImbalancedPaths(int p, int balp) {
  std::cout << "path: " << p << " is not a mirror image of " << balp << std::endl;
  std::cout << "     ";
  PrintPath(p, std::cout);
  std::cout << "bal: ";
  PrintPathReverse(balp, std::cout);
}


int IntervalGraph::CheckPathContinuity(int p) {
  int pos;
  int edge, index;
  int nextEdge, nextIndex;
  for (pos = 0; pos < pathLengths[p]-1; pos++ ) {
    edge = paths[p][pos].edge;
    index = paths[p][pos].index;
    nextEdge = paths[p][pos+1].edge;
    nextIndex = paths[p][pos+1].index;
    if (edge == -1 or nextEdge == -1)
      continue;
    if ((*edges[edge].intervals)[index].readPos +
				(*edges[edge].intervals)[index].length -
				vertices[edges[edge].dest].vertexSize != 
				(*edges[nextEdge].intervals)[nextIndex].readPos) {
      std::cout << "path: " << p << " is off by " <<
				((*edges[edge].intervals)[index].readPos +
				 (*edges[edge].intervals)[index].length -
				 vertices[edges[edge].dest].vertexSize) -
				(*edges[nextEdge].intervals)[nextIndex].readPos << std::endl;
      return 0;
    }
  }
  return 1;
}

void IntervalGraph::CheckAllPathsContinuity(int fatal) {
  int p;
  for (p = 0; p < paths.size(); p++) {
    if (!CheckPathContinuity(p))
      assert(!fatal);
  }
}

int IntervalGraph::CheckPathBalance(int p, int balp) {
  int pos;
  int edge, intv, balEdge, balIntv;
  if (pathLengths[p] > 0) {
    if (pathLengths[balp] != pathLengths[p]) {
      return 0;
    }
    else {
      for (pos = 0; pos < pathLengths[p]; pos++) {
				edge = paths[p][pos].edge;
				intv = paths[p][pos].index;
				balEdge = paths[balp][pathLengths[balp] - pos - 1].edge;
				balIntv = paths[balp][pathLengths[balp] - pos - 1].index;
				assert(edge < 0 or intv < 0 or  (*edges[edge].intervals)[intv].length >= 0);
				assert(balEdge < 0 or intv < 0 or (*edges[balEdge].intervals)[balIntv].length >= 0);
				if (edge < 0 and balEdge >= 0 or
						edge >= 0 and balEdge < 0) {
						 return 0;
						}
				if (edge >= 0 and balEdge >= 0 and 
						(*edges[edge].intervals)[intv].length != 
						(*edges[balEdge].intervals)[balIntv].length) {
					return 0;
				}
      }
    }
  }
  // No imbalances detected, return 0K
  return 1;
}
	

void IntervalGraph::PrintPath(int p, std::ostream &pathOut) {
  int pos, edge, intv;
  pathOut << std::setw(8) <<  p << " len: " << pathLengths[p];
  for (pos = 0; pos < pathLengths[p]; pos++) {
    edge = paths[p][pos].edge;
    intv = paths[p][pos].index;
    if (edge != -1)
      pathOut << " (p " << pos << ", e " << edge << ", i " << edges[edge].index << ", I " 
							<< intv << ", R " 
							<< (*edges[edge].intervals)[intv].readPos << ", E " 
							<< (*edges[edge].intervals)[intv].edgePos << ", L "
							<< (*edges[edge].intervals)[intv].length << ", v "
							<< vertices[edges[edge].dest].vertexSize << ") ";
    else
      pathOut << " -1 (0) ";
  }
  pathOut << std::endl;
}


void IntervalGraph::PrintPathReverse(int p, std::ostream &pathOut) {
  int pos, edge, intv;
  pathOut << std::setw(8) << p << " len: " << pathLengths[p];
  int len = pathLengths[p];
  for (pos = 0; pos < pathLengths[p]; pos++) {
    edge = paths[p][len - pos - 1].edge;
    intv = paths[p][len - pos - 1].index;
    if (edge != -1)
      pathOut << " (p " << pos << ", e " << edge << ", i " << edges[edge].index << ", I " 
							<< intv << ", R " 
							<< (*edges[edge].intervals)[intv].readPos << ", E " 
							<< (*edges[edge].intervals)[intv].edgePos << ", L "
							<< (*edges[edge].intervals)[intv].length << ", v "
							<< vertices[edges[edge].dest].vertexSize << ") ";

    else
      pathOut << " -1 (0) ";
  }
  pathOut << std::endl;
}

void IntervalGraph::PrintPaths(std::string pathName) {
  std::ofstream pathOut;
  openck(pathName, pathOut, std::ios::out);
  int p;
  int pos;
  int edge, intv;
  for (p = 0; p < paths.size(); p+=2 ) {
    if (pathLengths[p] > 0) {
      pathOut << "     ";
      PrintPath(p, pathOut);
    }
    int balp = p+1;
    if (pathLengths[balp] > 0) {
      pathOut << "bal: ";
      PrintPath(balp, pathOut);
    }
  }
  pathOut.close();
}

void IntervalGraph::AssignVertexSizes() {
	int v;
	for (v = 0; v < vertices.size(); v++) {
		vertices[v].vertexSize = vertexSize;
	}
}

void IntervalGraph::ReadIntervalGraph(std::string &bGraphName,
																			std::string &intervalName, 
																			std::string pathName, 
																			int skipIntervals) {
  // The interval graph is a combination of graph and intervals
  ReadBGraph(bGraphName, vertices, edges);

	AssignVertexSizes();
  CheckVertices(vertices, edges);
  CheckEdges(vertices, edges);

	if (skipIntervals) {
		CheckBalance();
		InitializeFlags();
		return;
	}

  maxReadIndex = ReadReadIntervals(intervalName, edges);

  // All the methods here work with intervals sorted by read pos
  // but other code uses them sorted by edge pos
  // Restore the order when writing the graph
  SortAllEdgeIntervalsByReadPos();
	
  // Assign each read interval its order in the path it is part of
  if (pathName != "") {
    ReadReadPaths(pathName, paths, pathLengths);
		std::cout << "Done reading graph." << std::endl;
    AssignPathOrderToEdges();
  }
  else {
    AssignIntervalPathOrder();
  }

  //	AssignEdgesToIntervals();
  CheckBalance();
  CheckAllPathsBalance(1);
  CheckGraphStructureBalance();
  InitializeFlags();
}


void IntervalGraph::MergeEdgeIntervals(int source, int dest) {

  int sourceLength = edges[source].length;
  int destLength   = edges[dest].length;

  int i;
  int numDestIntervals = edges[dest].intervals->size();

  edges[dest].intervals->resize(edges[dest].intervals->size() + 
															 edges[source].intervals->size());

  int destPos;

  // Copy over the read intervals
  for (i = 0; i < edges[source].intervals->size(); i++ ) {
    (*edges[dest].intervals)[i + numDestIntervals] = (*edges[source].intervals)[i];
    destPos = i + numDestIntervals;
  }
  SortReadIntervalsByReadPos(*edges[dest].intervals);
  int read, pathPos;
  for (i = 0; i < (*edges[dest].intervals).size(); i++) {
    /*
      The read and pathPos do not change when merging
      the edge intervals, but the original edge, and position
      on the edge do.  Reset all of them since the order
      changes when sorting.
    */
    read = 		(*edges[dest].intervals)[i].read;
    pathPos = (*edges[dest].intervals)[i].pathPos;
    paths[read][pathPos].edge  = dest;
    paths[read][pathPos].index = i;
  }
}

int IntervalGraph::GetOutEdgeIndex(int vertex, int edge) {
  int e;
  for (e = 0; e < 4; e++ ) {
    if (vertices[vertex].out[e] == edge)
      return e;
  }
  return 4;
}

int IntervalGraph::GetInEdgeIndex(int vertex, int edge) {
  int e;
  for (e = 0; e < 4; e++ ) {
    if (vertices[vertex].in[e] == edge)
      return e;
  }
  return 4;
}

void IntervalGraph::RemoveAllSimpleBulges(int minBulgeSize) {
  int nRemoved = 0;
  int removeBulgeIter = 0;
  do {
    nRemoved = RemoveSimpleBulges(minBulgeSize);
    ++removeBulgeIter;
    std::cout << "remove bulge iter: " << removeBulgeIter << " " << nRemoved << std::endl;
  }
  while (nRemoved > 0);

}

int IntervalGraph::RemoveSimpleBulges(int minBulgeSize) {
  
  // Remove simple bulges, directed cycles of length 2.  This was 
  // mainly written as practice for merging intervals, to see if it 
  // would work, and to eek out some better results for component size.
  int v, a, b;
  std::vector<int> removedEdges;
  int removedEdge;
  Unflag();
  int edgeA, edgeB;
  int balancedEdge;
  int edgeIndex;
  
  for (v = 0; v < vertices.size(); v++ ){
    // Find which edges go into the same position
    //    if (vertices[v].OutDegree() == 2) {
    for (a = 0; a < 3 ; a++ ){
      for (b = a + 1; b < 4 ; b++ ) {
				if (vertices[v].out[a] != -1 and
						vertices[v].out[b] != -1 and
						edges[vertices[v].out[a]].dest == 
						edges[vertices[v].out[b]].dest) {
					if (edges[vertices[v].out[a]].length < minBulgeSize and
							edges[vertices[v].out[b]].length < minBulgeSize) {
						// There is a simple bulge.  Need to check if there is a preference on 
						// which one to remove.  There is a preference when the balanced
						// edge of one of the edges has already been removed.
						if (edges[vertices[v].out[a]].flagged == GraphEdge::Marked) {
							removedEdge = RemoveSimpleBulge(v, vertices[v].out[b], vertices[v].out[a], edgeIndex);
							removedEdges.push_back(removedEdge);
						}
						else if (edges[vertices[v].out[b]].flagged == GraphEdge::Marked) {
							removedEdge = RemoveSimpleBulge(v, vertices[v].out[a], vertices[v].out[b], edgeIndex);
							removedEdges.push_back(removedEdge);
						}
						else {
							// There is no preference on which edge to merge into the other.
							// Keep the edge of higher multiplicity
							if (edges[vertices[v].out[a]].balancedEdge == vertices[v].out[b]) {
								// The bulge involves two balanced edges.  Since we'll be deleting
								// the balance, we mark the balance of the originals to themselves 
								// so that the bookkeeping is correct (no edges remain without balanced
								// edges).
								edges[vertices[v].out[a]].balancedEdge = vertices[v].out[a];
								edges[vertices[v].out[b]].balancedEdge = vertices[v].out[b];
							}
							// Remove the edge of lower multiplicity
							removedEdge = RemoveSimpleBulgeLowerMult(v, vertices[v].out[a], vertices[v].out[b], edgeIndex);
							removedEdges.push_back(removedEdge);
							balancedEdge = edges[removedEdge].balancedEdge;
							// std::cout << "removing bulged edge: " << removedEdge << " and giving preference to " << balancedEdge << std::endl;
							edges[balancedEdge].flagged = GraphEdge::Marked;
							//  std::cout << "removing edge " << removedEdge << " and giving preference to " << balancedEdge << std::endl;
						}
					}
				}
      }
    }
    //    }
  }
  // Now do a sanity check on the removed edges.  For every edge 
  // in the removed set, it's balanced edge should have been removed.
  
  int e, e2;
  std::sort(removedEdges.begin(), removedEdges.end());
  for (e = 0; e < removedEdges.size(); e++) {
    removedEdge = removedEdges[e];
    balancedEdge = edges[removedEdge].balancedEdge;
    if (std::binary_search(removedEdges.begin(), removedEdges.end(),
													 balancedEdge) == 0) {
      std::cout << "error, removed " << removedEdge << " but not " 
								<< edges[removedEdge].balancedEdge << std::endl;
    }
  }

  std::cout << "Simple bulge removal removed: " << removedEdges.size() << " edges " << std::endl;
  std::vector<int> nullVertices;
  /* 
     Remove the bulges from the graph.
     At this point in time the paths are marked for deletion, but they are not 
     removed so that they may be re-routed.
  */
		 
  Prune(nullVertices, removedEdges);

  /* 
     For now re-route before condensing simple paths.  If it were done afterwards, there 
     would be gapped intervals being joined together. That's not so bad, but just not 
     yet figured out.
  */
  //	RouteRemovedIntervals();
  SortAllEdgeIntervalsByReadPos();
  UpdateAllPathIndices();
  CondenseSimplePaths();
  CheckAllPathsBalance(1);
  return removedEdges.size();
}



int IntervalGraph::IsEdgeSuspect(int e, int polyNucLength) {
  // edge e 
  int p;
  if (polyNucLength > edges[e].length)
    return 0;

  int polyNucPos = 0;
  int lastPolyNuc = -1;
  int polyNucFound = 0;
  for (p = 1; p < edges[e].length; p++ ) {
    if (edges[e].seq.seq[polyNucPos] != edges[e].seq.seq[p])
      polyNucPos = p;
    else if (p - polyNucPos >= polyNucLength) {
      polyNucFound = 1;
      lastPolyNuc = p;
    }
    if (p > vertexSize ) {
      // There exists a k-mer here that does not have 
      // a homopolymer in it.  There fore this edge is trusted
      if (lastPolyNuc < p - vertexSize)
				return 0;
    }
  }
  return 1;
}


int IntervalGraph::MarkSuspectEdges(int polyNucLength) {
  int e;
  Unsuspect();
  if (vertexSize <= 0) {
    std::cout << "ERROR, the vertex size needs to be set to mark " 
							<< "suspect edges! " << std::endl;
    exit(0);
  }

	//  std::cout << "marking suspect edges!! " << std::endl;
  for (e = 0; e < edges.size(); e++ ) {
    if (IsEdgeSuspect(e, polyNucLength)) {
      edges[e].suspect = GraphEdge::Marked;
      /*
				std::cout << " edge : " << e << " is suspect " << std::endl;
      */
    }
    else
      edges[e].suspect = GraphEdge::NotMarked;
  }
}

int IntervalGraph::RemoveSimpleBulgeLowerMult(int vertex, int e1, int e2, int &edgeIndex) {
  
  // Merge the edge of lower multiplicity into the edge of higher.
  int sourceEdge, destEdge;
  int destVertex;
  destVertex = edges[e1].dest;

  sourceEdge = e1;
  destEdge   = e2;

  // check the lower mult. edge
  if (edges[e2].multiplicity > edges[e1].multiplicity) {
    sourceEdge = e2;
    destEdge = e1;
  }
  
  RemoveSimpleBulge(vertex, destEdge, sourceEdge, edgeIndex);

  return sourceEdge;
}

int IntervalGraph::RemoveSimpleBulge(int vertex, int destEdge, int sourceEdge, int &edgeIndex) {
  
  // Merge the edge of lower multiplicity into the edge of higher.
  int destVertex;
  destVertex = edges[destEdge].dest;

  MergeEdgeIntervals(sourceEdge, destEdge);
  
  //  RemoveEdge(sourceEdge);
  // Unlink the out edge
  edgeIndex = GetOutEdgeIndex(vertex, sourceEdge);
  vertices[vertex].out[edgeIndex] = -1;

  // Unlink the in edge
  edgeIndex  = GetInEdgeIndex(destVertex, sourceEdge);
  vertices[destVertex].in[edgeIndex] = -1;

  /* 
     Remove this for now since we'll just merge the edge intervals since 
     the source and dest edges do not change.
     MarkIntervalsInEdgeForRemoval(sourceEdge);
  */
  return sourceEdge;
}

class CountAndStoreVertices {
public:
  int size;
  int length;
  int maxSize;
  std::vector<TEdge> *edges;
  std::vector<TVertex> *vertices;
  std::vector<int> componentIndices, edgeIndices;

  void operator()(int vertexIndex) {
    int e;
    size++;
    if (maxSize == -1 and componentIndices.size() > maxSize) {
      return;
    }
    componentIndices.push_back(vertexIndex);
    int edgeIndex;
    int srcIndex;
    int destIndex;
    for (e = (*vertices)[vertexIndex].FirstIn(); 
				 e < (*vertices)[vertexIndex].EndIn(); 
				 e = (*vertices)[vertexIndex].NextIn(e) ) {
      assert((*vertices)[vertexIndex].in[e] != -1);
      edgeIndex = (*vertices)[vertexIndex].in[e];
      srcIndex = (*edges)[edgeIndex].src;
      if (edgeIndex >= 0 and
					(*edges)[edgeIndex].marked == GraphEdge::NotMarked ) {
				edgeIndices.push_back(edgeIndex);
				length += (*edges)[edgeIndex].length;
				(*edges)[edgeIndex].marked = GraphEdge::Marked;
      }
    }

    for (e = (*vertices)[vertexIndex].FirstOut(); 
				 e < (*vertices)[vertexIndex].EndOut(); 
				 e = (*vertices)[vertexIndex].NextOut(e) ) {
      assert((*vertices)[vertexIndex].out[e] != -1);
      edgeIndex = (*vertices)[vertexIndex].out[e];
      if (edgeIndex >= 0 and
					(*edges)[edgeIndex].marked == GraphEdge::NotMarked) {
				edgeIndices.push_back(edgeIndex);
				length += (*edges)[edgeIndex].length;
				(*edges)[edgeIndex].marked = GraphEdge::Marked;
      }
    }
  }
};

void IntervalGraph::RemoveBalPreferred() {
  int e;
  for (e = 0; e < edges.size(); e++) 
    edges[e].balPreferred = GraphEdge::NotMarked;
}

void IntervalGraph::Unsuspect(){
  int e;
  for (e = 0; e < edges.size(); e++) 
    edges[e].suspect = GraphEdge::NotMarked;
}

void IntervalGraph::Unflag() {
  int v, e;
  for (v = 0; v < vertices.size(); v++ )
    vertices[v].flagged = GraphVertex::NotMarked;
  for (e = 0; e < edges.size(); e++)
    edges[e].flagged = GraphEdge::NotMarked;
}

void IntervalGraph::Untraverse() {
  int v, e;
  for (v = 0; v < vertices.size(); v++ )
    vertices[v].traversed = GraphVertex::NotMarked;
  for (e = 0; e < edges.size(); e++)
    edges[e].traversed = GraphEdge::NotMarked;
}

void IntervalGraph::Unmark() {
  int v, e;
  for (v = 0; v < vertices.size(); v++ )
    vertices[v].marked = GraphVertex::NotMarked;
  for (e = 0; e < edges.size(); e++)
    edges[e].marked = GraphEdge::NotMarked;
}

void IntervalGraph::InitializeFlags() {
  int v, e;
  for (v = 0; v < vertices.size(); v++ )
    vertices[v].Unmark();
  for (e = 0; e < edges.size(); e++)
    edges[e].Unmark();
}

int IntervalGraph::RemoveSmallComponents(int length, 
																				 std::string &readsFile, std::string &componentReadsFile) {

  int v, cv, ce;
  CountAndStoreVertices countSize;
  countSize.vertices = &vertices;
  countSize.edges    = &edges;
  countSize.maxSize  = length;
  Unmark();
  std::vector<int> verticesToRemove, edgesToRemove;
  int component = 0;
  for (v = 0; v < vertices.size(); v++ ) {
    if (vertices[v].marked == GraphVertex::NotMarked ) {
      countSize.size = 0;
      countSize.length = 0;
      countSize.componentIndices.clear();
      countSize.edgeIndices.clear();
      TraverseDFS(vertices, edges, v, countSize);
      if (countSize.length < length) {
				// Need to push back everything in the component
				for (cv = 0; cv < countSize.componentIndices.size(); cv++) {
					verticesToRemove.push_back(countSize.componentIndices[cv]);
				}
				for (ce = 0; ce < countSize.edgeIndices.size(); ce++) {
					edgesToRemove.push_back(countSize.edgeIndices[ce]);
				}
      } 
      ++component;
    }
  }
  std::cout << "component removal removed: " << verticesToRemove.size() << " vertices  / "
						<< vertices.size() << " and : " 
						<< edgesToRemove.size() << " edges / " 
						<< edges.size() << std::endl;

  int e, i;
  MarkIntervalsInEdgeForRemoval(edgesToRemove);
  SimpleSequenceList reads;
  std::ofstream compReadsOut;
  if (readsFile != "") {
    std::cout << "Printing small component reads to: " << componentReadsFile << std::endl;
    openck(componentReadsFile, compReadsOut, std::ios::out);
    ReadSimpleSequences(readsFile, reads);
    AppendReverseComplements(reads);
    int er;
    int read;
    std::stringstream titlestrm;
    for (er = 0; er < edgesToRemove.size(); er++ ) {
      e = edgesToRemove[er];
      for (i = 0; i < (*edges[e].intervals).size(); i++ ) {
				read = (*edges[e].intervals)[i].read;
				titlestrm.str("");
				titlestrm << read;
				if (pathLengths[read] > 0) {
					reads[read].PrintSeq(compReadsOut, titlestrm.str());
					pathLengths[read] = 0;
				}
      }
    }
    compReadsOut.close();
  }
	
  Prune(verticesToRemove, edgesToRemove);
  int numRemoved = RemoveMarkedIntervals();
  std::cout << "after removing components, removed " << numRemoved << " paths " << std::endl;


  for (e = 0; e < edges.size();e++ ){ 
    for (i = 0; i < (*edges[e].intervals).size(); i++) { 
      assert((*edges[e].intervals)[i].pathPos >= 0);
    }
  }
  CheckAllPathsBalance(1);
  return verticesToRemove.size();
}


void IntervalGraph::RemoveEdges(std::vector<int> &edgesToRemove, std::vector<int> &orphanedVertices) {
  int e;
  for (e = 0; e < edgesToRemove.size(); e++ ){ 
    RemoveEdge(edgesToRemove[e], orphanedVertices);
  }
}

void IntervalGraph::ConcatenateEdgeSequence(int vertex, int inEdge, int outEdge) {

  // Copy the edge from outEdge into in edge
  // and update the edge lengths
  int oldEdgeLength = edges[inEdge].length;
  edges[inEdge].seq.length += edges[outEdge].seq.length - vertexSize;

  unsigned char* newSeq;
  // keep the old sequence
  newSeq = new unsigned char[edges[inEdge].seq.length];
  memcpy(newSeq, edges[inEdge].seq.seq, oldEdgeLength);
  
  // Make sure we are not about to write over memory 
  // starting before the end of the edge
  assert(edges[inEdge].seq.length > vertexSize);
  
  memcpy((unsigned char*) (newSeq + oldEdgeLength - vertexSize),
				 edges[outEdge].seq.seq, edges[outEdge].seq.length);
  
  delete[] edges[inEdge].seq.seq;
  edges[inEdge].seq.seq = newSeq;
  edges[inEdge].length = edges[inEdge].seq.length;
}

void IntervalGraph::MergeSimplePath(int vertex, int inEdge, int outEdge) {
  /*
    SortReadIntervalsByReadPos(edges[inEdge].intervals);
    SortReadIntervalsByReadPos(edges[outEdge].intervals);
  */
  //  std::cout << "Merging paths " << inEdge << " <" << vertex << "- " << outEdge << std::endl;
  // do a couple of sanity checks.
  assert(vertices[vertex].InDegree() == 1);
  //  assert(vertices[vertex].OutDegree() == 1);
  
  // join or append read intervals if necessary
  RerouteSimplePathIntervals(vertex, inEdge, outEdge);

  ConcatenateEdgeSequence(vertex, inEdge, outEdge);
  // Update the length of the edge, and the sequence
  
  SkipOutEdge(vertex, inEdge, outEdge);
  
  // Mark this edge as not used
  edges[outEdge].dest = -1;
  edges[outEdge].src  = -1;

  // Mark this vertex as not used.
  int inIndex, outIndex;
  inIndex  = vertices[vertex].LookupInIndex(inEdge);
  outIndex = vertices[vertex].LookupOutIndex(outEdge);
  assert(inIndex >= 0);
  //	assert(outIndex >= 0);
  vertices[vertex].in[inIndex]   = -1;
  if (outIndex >= 0)
    vertices[vertex].out[outIndex] = -1;

  SortReadIntervalsByReadPos(*edges[inEdge].intervals);
  UpdatePathIndices(inEdge);

  if (edges[outEdge].guarded == GraphEdge::Marked)
    edges[inEdge].guarded = GraphEdge::Marked;
}

void IntervalGraph::UpdateAllPathIndices() {
  int e;
  for (e = 0; e < edges.size(); e++) 
    UpdatePathIndices(e);
}
	 
void IntervalGraph::UpdatePathIndices(int edge) {
  int i;
  int read, pathPos;
  for (i = 0; i < edges[edge].intervals->size(); i++) { 
    if (!IsIntervalMarkedForRemoval(edge, i)) {
      read = (*edges[edge].intervals)[i].read;
      pathPos = (*edges[edge].intervals)[i].pathPos;
      assert(read >= 0);
      assert(read < paths.size());
      assert(pathPos >= 0);
      //			std::cout << "updating path: " << read << " " << pathPos << " ( " << pathLengths[read] << ") -> " << i << " " << paths.size() << std::endl;
      assert(pathPos < pathLengths[read]);
      paths[read][pathPos].index = i;
    }
  }
}

void IntervalGraph::SortAllEdgeIntervalsByReadPos() {
  int e;
  for (e = 0; e < edges.size(); e++) {
    SortReadIntervalsByReadPos(*edges[e].intervals);
  }
}


void IntervalGraph::SortAllEdgeIntervalsByEdgePos() {
  int e;
  for (e = 0; e < edges.size(); e++) {
    SortReadIntervals(*edges[e].intervals);
  }
}

void IntervalGraph::SkipOutEdge(int vertex, int inEdge, int outEdge) {

	// Transform part of the graph of 
	//     the form  src--inEdge-->vertex--outedge-->dest
	//     to   --inEdge->dest
	//     
	// In edge now becomes the balance of outEdge->balancedEdge.
	// 
  // Unlink outEdge from graph
  int destVertex;
  int srcVertex;

  srcVertex  = edges[inEdge].src;
  destVertex = edges[outEdge].dest;

  // Fix the destination of the in edge so that 
  // it skips 'vertex'
  edges[inEdge].dest = destVertex;

  // Now fix the in edge from the dest vertex
  // have   vertex -- outEdge --> destVertex
  // we want the index of this.
  int inEdgeIndex = vertices[destVertex].LookupInIndex(outEdge);
  assert(inEdgeIndex != vertices[destVertex].EndIn());

  // point back past the skipped edge.
  vertices[destVertex].in[inEdgeIndex] = inEdge;

  // Fix the balanced edge of the skipped edge to reference the 
  // in edge.
  // We hope that only balanced operations will be performed on the graph

  int balOutEdge;
  balOutEdge = edges[outEdge].balancedEdge;

  edges[balOutEdge].balancedEdge = inEdge;

  int balInEdge;
  balInEdge = edges[inEdge].balancedEdge;
  if (edges[balInEdge].balancedEdge == -1) {
    // The in-edge references an edge that has been removed.
    // This can only happen if balanced edges have already been
    // skipped.  So, it's safe to make inedge point to the balanced
    // edge that the out edge uses, since it's already been merged with that.
    // I should draw an ascii diagram for this, but I don't want to now.
    edges[inEdge].balancedEdge = edges[outEdge].balancedEdge;
  }
  edges[outEdge].balancedEdge = -1;
}


int IntervalGraph::CondenseSimplePaths() {
  std::vector<int> removedVertices;
  std::vector<int> removedEdges;

  int vertex;
  vertex = 0;
  int destVertex;
  int outEdge, outEdgeIndex;
  int followingVertex, followingEdge, followingEdgeIndex;
  int prevLength;
  while (vertex < vertices.size()) {
    // If this vertex is the beginning of a path, try to simplify it.
    if (vertices[vertex].OutDegree() != 1 or vertices[vertex].InDegree() != 1) {
      for (outEdgeIndex = vertices[vertex].FirstOut();
					 outEdgeIndex < vertices[vertex].EndOut();
					 outEdgeIndex = vertices[vertex].NextOut(outEdgeIndex)) {
				outEdge = vertices[vertex].out[outEdgeIndex];
				destVertex = edges[outEdge].dest;
				prevLength = edges[outEdge].length;
				while (vertices[destVertex].OutDegree() == 1 and
							 vertices[destVertex].InDegree() == 1) {

					// Found an vertex --> destVertex --> some other vertex
					// Find out where this vertex goes.
					followingEdgeIndex = vertices[destVertex].FirstOut();
					followingEdge      = vertices[destVertex].out[followingEdgeIndex];
					followingVertex    = edges[followingEdge].dest;
		
					MergeSimplePath(destVertex, outEdge, followingEdge);
	       
					// Remove this vertex and the outEdge
					removedVertices.push_back(destVertex);
					removedEdges.push_back(followingEdge);
		
					// Re-assign the destination edge
					destVertex = followingVertex;
				}
      }
    }
    vertex++;
  }
  Prune(removedVertices, removedEdges);
  return removedEdges.size();
}



void IntervalGraph::MarkPathsThroughEdgeForRemoval(int edgeIndex) {
  std::vector<int> pathEdges, pathIndices;
  int i;
  // Note: I check to see if an interval is traversed so that
  // I don't re-mark paths for removal.  There is nothing terribly
  // wrong with doing that, and so to save space, the traversed
  // flag may be removed.
  for (i = 0; i < edges[edgeIndex].intervals->size(); i++) {
    if ((*edges[edgeIndex].intervals)[i].read >= 0 and
				(*edges[edgeIndex].intervals)[i].traversed == 0) {
      // This edge has not yet been flagged for removal, do it now
      pathEdges.clear();
      pathIndices.clear();
      TracePath(edgeIndex, i, pathEdges, pathIndices);
      MarkPathForRemoval(pathEdges, pathIndices);
    }
  }
}

void IntervalGraph::MarkIntervalsInEdgeForRemoval(std::vector<int> &edgeIndices) {
  int e;
  for (e = 0; e < edgeIndices.size(); e++) {
    MarkIntervalsInEdgeForRemoval(edgeIndices[e]);
  }
}

void IntervalGraph::MarkIntervalsInEdgeForRemoval(int edgeIndex) {
  int i;
  int read;
  int pathPos;
  /* 
     Given an edge, mark all intervals in it for removal.
  */ 
  //	std::cout << "marking intervals in edge " << edgeIndex << std::endl;
  for (i = 0; i < edges[edgeIndex].intervals->size(); i++ ) { 
    MarkIntervalForRemoval(edgeIndex, i);
  }
}

void IntervalGraph::DiscardGappedPaths() {

  /* 
     Discard paths that have gaps in them (a path is a series of edges and indexes
     on the edge ( (e1,i1), (e2,i2), ... , (en,in) ).
     The path is gapped if one of the pairs is cleared:
     ((e1,i1), (-1,-1), ... (en,in)).

  */
  int p, pi;
  int pathIsGapped;
  for (p = 0; p < paths.size(); p++) {
    pathIsGapped = 0;
    for (pi = 0; pi < pathLengths[p]; pi++) {
      /* Either both are not -1, or both are */
      if (paths[p][pi].edge == -1 and 
					paths[p][pi].index == -1) {
				pathIsGapped = 1;
				break;
      }
      else {
				assert(paths[p][pi].edge != -1 and paths[p][pi].index != -1);
      }
    }
    if (pathIsGapped) {
      /*
				std::cout << "path: " << p  << " of len: " << pathLengths[p] << " is gapped " << std::endl;
				for (pi = 0; pi < pathLengths[p]; pi++) {
				std::cout << paths[p][pi].edge << " " << paths[p][pi].index << ", ";
				}
				std::cout << std::endl;
      */
      /*
				There exists a gap in this path.  There are a few options.
				- Remove this path from existence since it won't help resolving
				any equivalent transformations.
				- Keep the longest stretch of this path.  In some small
				cases this may help, but I don't anticipate that.
				
				for now,remove the entre path.
      */

      std::vector<int> pathEdges, pathIndices;

      for (pi = 0; pi < pathLengths[p]; pi++) {
				if (paths[p][pi].edge != -1) {
					pathEdges.push_back(paths[p][pi].edge);
					pathIndices.push_back(paths[p][pi].index);
				}
				else {
					if (pathEdges.size() > 0) {
						/*
							std::cout << "removing subpath: " << std::endl;
							int pei;
							for (pei = 0; pei < pathEdges.size(); pei++) {
							std::cout << " " << pathEdges[pei] << " " << pathIndices[pei] << " ";
							}
							std::cout << std::endl;
						*/
						MarkPathForRemoval(pathEdges, pathIndices);
						pathEdges.clear();
						pathIndices.clear();
					}
				}
				paths[p][pi].edge = -1;
				paths[p][pi].index = -1;
      }
      if (pathEdges.size() > 0) {
				// process the last set of edges, if they exist
				/*
					std::cout << "removing subpath: " << std::endl;
					int pei;
					for (pei = 0; pei < pathEdges.size(); pei++) {
					std::cout << " " << pathEdges[pei] << " " << pathIndices[pei] << " ";
					}
					std::cout << std::endl;
				*/
				MarkPathForRemoval(pathEdges, pathIndices);
				pathEdges.clear();
				pathIndices.clear();
      }
      pathLengths[p] = 0;
    }
  }
  RemoveMarkedIntervals();
  //	RemoveLowCoverageEdges(2);
}

int IntervalGraph::DoesPathRepeat(int readIndex, int pathPos) {
  int p;
  assert(pathPos < pathLengths[readIndex]);
  for (p = 0; p < pathPos-1; p++) {
    if (paths[readIndex][p].edge == paths[readIndex][pathPos].edge)
      return 1;
  }
  return 0;
}


int IntervalGraph::RouteRemovedIntervals(int maxSearchLength) {
  int e, i, p;
  int readIndex;
  int curPathPos;
  int numRouted = 0;
  //	std::cout << "Rerouting removed intervals"  << std::endl;
  UntraverseReadIntervals();
  Untraverse();
  std::vector<int> pathEdges, pathIndices;
  int compReadIndex;
  for (e = 0; e < edges.size(); e++ ) {
    for (i = 0; i < edges[e].intervals->size(); i++) {
      if (! IsIntervalMarkedForRemoval(e, i)) {
				// and
				//					edges[e].intervals[i].traversed == 0) {
				readIndex = (*edges[e].intervals)[i].read;
				/*
					std::cout << "searching for alternate paths for " << e << " " 
					<< edges[e].index << " " << readIndex << std::endl;
					PrintPath(readIndex, std::cout);
				*/
				int compEdge, compIndex;
				int compPathPos, compPathNext;

				// If this graph is balanced, we process the complimentary path
				// at the same time as the forward path.  If this path is 
				// complimentary, wait until the forward path is reached.
				if (isBalanced and !IsForwardRead(readIndex))
					continue;

				compReadIndex = GetCompReadIndex(readIndex);
				// Try and trace this path
				curPathPos = (*edges[e].intervals)[i].pathPos;
				if (curPathPos < pathLengths[readIndex]-1) {
					// This is not the last edge on the path, so it may have been gapped.
					int curPathIndex, curPathEdge;
					assert(readIndex >= 0);
					assert(curPathPos >= 0);
					curPathIndex = paths[readIndex][curPathPos].index;
					curPathEdge =  paths[readIndex][curPathPos].edge;

					assert(curPathEdge != -1);
					assert(curPathIndex != -1);
					if (paths[readIndex][curPathPos+1].edge == -1) {
						// The path is missing some edges.  If it's possible 
						// to re-join this path back to the graph, do so.
						//						std::cout << e << " " << i << " has been deleted! " << std::endl;
						int nextPathPos, nextPathIndex, nextPathEdge;
						for (nextPathPos = curPathPos+2; 
								 nextPathPos < pathLengths[readIndex]; 
								 nextPathPos++ ) {
							if (paths[readIndex][nextPathPos].edge != -1)
								/* 
									 Found the continuation of the path that has
									 not been deleted.  Break now and try and link
									 the path at the previous undeleted pos to next. 
								*/
								break;
						}
						// Only route the paths where the curPathPos and nextPathPos are 
						// within the range 0 .. pathLengths-1, so that part of the 
						// path is known.
						if (nextPathPos < pathLengths[readIndex]) {
							nextPathIndex = paths[readIndex][nextPathPos].index;
							nextPathEdge  = paths[readIndex][nextPathPos].edge;
							// std::cout << "the path resumes at " << nextPathEdge << " " << nextPathIndex << std::endl;
							std::vector<int> altPathEdges;

						
							if (curPathEdge != nextPathEdge) {
								//std::cout << "searching path for " << readIndex << std::endl;
								int foundAlternatePath = 0;
								int advance = 0;
								int gappedLength;
								int pathRepeats = 0;
								for (advance = 0; advance < 3 
											 and !foundAlternatePath
											 and nextPathPos < pathLengths[readIndex]
											 and paths[readIndex][nextPathPos].edge != -1; nextPathPos++, advance++ ){ 
									if (DoesPathRepeat(readIndex, nextPathPos)) {
										pathRepeats = 1;
										continue;
									}
									nextPathIndex = paths[readIndex][nextPathPos].index;
									nextPathEdge  = paths[readIndex][nextPathPos].edge;
									gappedLength = (*edges[nextPathEdge].intervals)[nextPathIndex].readPos - 
										((*edges[curPathEdge].intervals)[curPathIndex].readPos + 
										 (*edges[curPathEdge].intervals)[curPathIndex].length -
										 vertices[edges[curPathEdge].dest].vertexSize);
									// Search for an alternate path that is of similar length to the original
									// path.  
									if (StoreAlternatePath(curPathEdge, nextPathEdge, 
																				 altPathEdges, (int)( gappedLength * 1.20) )) {
										if (pathRepeats) {
											//std::cout << "found alternate path for cyclic path: " << readIndex << std::endl;
										}
										foundAlternatePath = 1;
										break;
									}
								}
								if (foundAlternatePath) {
									/*std::cout << "found alternate path for " << readIndex << std::endl;*/
									if (isBalanced and IsForwardRead(readIndex)) {
										compReadIndex = GetCompReadIndex(readIndex);
										compPathPos   = pathLengths[compReadIndex] - nextPathPos - 1;
										compPathNext  = pathLengths[compReadIndex] - curPathPos - 1;
										compEdge      = paths[compReadIndex][compPathPos].edge;
										compIndex     = paths[compReadIndex][compPathPos].index;
									}						
									else {
										// reset compliment indices since the graph is not complementary
										// or the complement has already been processed
										compPathPos = compPathNext = compEdge = compIndex = -1;
									}
									
									int toRemove;
									int toRemoveEdge, toRemoveInterval;
									for (toRemove = curPathPos + 1; toRemove < nextPathPos; toRemove++ ) {
										toRemoveEdge     = paths[readIndex][toRemove].edge;
										toRemoveInterval = paths[readIndex][toRemove].index;
										if (toRemoveEdge >= 0) {
											MarkIntervalForRemoval(toRemoveEdge, toRemoveInterval);
										}
									}
									for (toRemove = compPathPos + 1; toRemove < compPathNext; toRemove++) {
										toRemoveEdge = paths[compReadIndex][toRemove].edge;
										toRemoveInterval = paths[compReadIndex][toRemove].index;
										if (toRemoveEdge >= 0) {
											MarkIntervalForRemoval(toRemoveEdge, toRemoveInterval);
										}
									}
										
									if (curPathPos+1 == nextPathPos) {
										std::cout << "ERROR: the positions in the read path should not be " << std::endl
															<< " adjacent when replacing a gapped path " << std::endl;
										assert(0);
									}
									if (altPathEdges.size() > 0) {
										numRouted++;
										int newLength, ne;
										newLength = 0;
										for (ne = 0; ne < altPathEdges.size(); ne++) {
											newLength += edges[altPathEdges[ne]].length - 
												vertices[edges[altPathEdges[ne]].dest].vertexSize;
										}
										
										ReplacePathRangeForward(readIndex,
																						curPathEdge, curPathIndex,
																						curPathPos+1, nextPathPos, altPathEdges);
										CheckPathContinuity(readIndex);

										assert(isBalanced and compReadIndex >= 0);
										std::vector<int> compPathEdges;
										FormComplimentPath(altPathEdges, compPathEdges);
										ReplacePathRangeReverse(compReadIndex, compEdge, compIndex,
																						compPathPos + 1, compPathNext, compPathEdges);
										CheckPathContinuity(compReadIndex);
										if (CheckPathBalance(readIndex, compReadIndex)==0) {
											std::cout << "Tried to replace path range " << compPathPos +1 
																<< " " << compPathNext - 1 << " " << compPathEdges.size() <<" ";
											int c;
											for (c = 0; c < compPathEdges.size(); c++) { std::cout <<" " << compPathEdges[c];}
											std::cout << std::endl;
											PrintImbalancedPaths(readIndex, compReadIndex);
										}

										int ap;
										for (ap = 0; ap < altPathEdges.size(); ap++) {
											assert(edges[altPathEdges[ap]].intervals->size() ==
														 edges[compPathEdges[compPathEdges.size() - ap - 1]].intervals->size());
										}
									}
									else {
										SplicePathRange(readIndex, curPathPos+1, nextPathPos-1);
										assert(isBalanced and compReadIndex >= 0);
										SplicePathRange(compReadIndex, compPathPos+1, compPathNext-1);
									}
								}
								else {
									//std::cout << "No alternate path found " << readIndex<< std::endl;
								}
							}
							else {
								// The deleted section loops back to itself, so just delete the intervening 
								// section
								SplicePathRange(readIndex, curPathPos+1, nextPathPos);

								compReadIndex = GetCompReadIndex(readIndex);
								compPathPos   = pathLengths[compReadIndex] - nextPathPos - 1;
								compPathNext  = pathLengths[compReadIndex] - curPathPos - 1;
								compEdge      = paths[compReadIndex][compPathPos].edge;
								compIndex     = paths[compReadIndex][compPathPos].index;

								assert(isBalanced and compReadIndex >= 0);
								SplicePathRange(compReadIndex, compPathPos, compPathNext-1);
							}
						} // end if nextPathPos < end
					} // end if curPathPos+1 is gapped 
				} // end if cur path pos is not at end
      } // end checking if edge is deleted
    }
  }
  SortAllEdgeIntervalsByReadPos();
  UpdateAllPathIndices();
  return numRouted;
}



void IntervalGraph::SplicePathRange(int readIndex, int spliceStart, int spliceEnd) {

  //
  // Remove spliceStart ... spliceEnd entirely from a path. 
  // This will effectively remove a read from the graph.  Unfortunately, for now
  // the sequence will be a bit messed up, since I doin't actually splice the read
  // I just shift the readPos offsets back.  In the future, I should
  // shift the readPos offsets back, and actually modify the corresponding read.
  assert (spliceEnd >= spliceStart);
  PathInterval *newPath;
  int splicedLength = spliceEnd - spliceStart + 1;
  int newPathLength = pathLengths[readIndex] - splicedLength;
  int p;
  int edge, intv;
  // Calculate the length of theread that is deleted.
  int deletedLength = 0;
  if (spliceStart == 0) {
    if (spliceEnd < pathLengths[readIndex]-1) {
      deletedLength = (*edges[paths[readIndex][spliceEnd+1].edge].intervals)[paths[readIndex][spliceEnd+1].index].readPos;
    }
  }
  else {
    if (spliceEnd < pathLengths[readIndex]-1) {
      assert(spliceStart>0);
      int startEdge = paths[readIndex][spliceStart-1].edge;
      int startIntv = paths[readIndex][spliceStart-1].index;
      int destVertex = edges[startEdge].dest;
      int resumeEdge = paths[readIndex][spliceEnd+1].edge;
      int resumeIntv = paths[readIndex][spliceEnd+1].index;
      if (startEdge == -1 or resumeEdge == -1) {
				// Something is wrong with this path, remove the entire thing.
				for (p = 0; p < pathLengths[readIndex]; p++) {
					edge = paths[readIndex][p].edge;
					intv = paths[readIndex][p].index;
					if (edge >= 0 && index >= 0 and
							!IsIntervalMarkedForRemoval(edge, intv)) {
						MarkIntervalForRemoval(edge, intv);
					}
				}
				return;
      }
      assert(resumeEdge >= 0);
      assert(resumeIntv >= 0);
      assert(startEdge >= 0);
      assert(startIntv >= 0);
      assert(spliceEnd + 1 < pathLengths[readIndex]);
      deletedLength = (*edges[resumeEdge].intervals)[resumeIntv].readPos -
				((*edges[startEdge].intervals)[startIntv].readPos + 
				 (*edges[startEdge].intervals)[startIntv].length - 
				 vertices[destVertex].vertexSize);
    }
    // else, if spliceEnd == readLengths[readIndex]-1, the entire end
    // of the path is deleted, so no readPos offsets are necessary
  }
  /*
    std::cout << "splicing out of: " << readIndex << " " << spliceStart <<" .. " << spliceEnd << " " 
    << " dl:" << deletedLength << std::endl;
  */
  // First remove all intervals corresponding to spliced region.
  for (p = spliceStart; p <= spliceEnd; p++) {
    edge = paths[readIndex][p].edge;
    intv = paths[readIndex][p].index;
    if (edge != -1 and intv != -1 and
				!IsIntervalMarkedForRemoval(edge, intv)) {
      MarkIntervalForRemoval(edge, intv);
    }
  }

  if (newPathLength > 0)
    newPath = new PathInterval[newPathLength];

  for (p = 0; p < spliceStart; p++ ) {
    assert(newPathLength > 0);
    newPath[p] = paths[readIndex][p];
  }
  for (p = spliceEnd + 1; p < pathLengths[readIndex]; p++) {
    assert(newPathLength > 0);
    newPath[p - splicedLength] = paths[readIndex][p];
    edge = paths[readIndex][p].edge;
    intv = paths[readIndex][p].index;
    if (!IsIntervalMarkedForRemoval(edge, intv)) {
      (*edges[edge].intervals)[intv].pathPos = p - splicedLength;
      (*edges[edge].intervals)[intv].readPos -= deletedLength;
    }
  }
  delete[] paths[readIndex];

  if (newPathLength > 0) {
    paths[readIndex] = newPath;
  }
  else {
    paths[readIndex] = NULL;
  }
  pathLengths[readIndex] = newPathLength;
}

int IntervalGraph::FormComplimentPath(std::vector<int> &origPath,
																			std::vector<int> &compPath) {
  // Given orig path, find the path in the graph that
  // traversed all the complimentary edges
  compPath.resize(origPath.size());
  int e;
  for (e = 0; e < origPath.size(); e++) {
    compPath[origPath.size() - e - 1] = edges[origPath[e]].balancedEdge;
  }
}



int IntervalGraph::MakeRoomForEdges(int readIndex, int intvEdge, int intvIndex,
																		int pathStart, int pathEnd,
																		std::vector<int> &newEdges) {
	// This makes room for a range in a path.  The path from pathStart...pathEnd-1
	// gets replaced by newEdges.
  int newSpace;
  newSpace = newEdges.size() - (pathEnd - pathStart);
  int p, e;
  int curReadPos;
  PathInterval *newPath;
  if (newSpace != 0) {
		// Sanity check.  Make sure that some space is being allocated or deleted.
    if (pathLengths[readIndex] + newSpace == 0) {
      std::cout << "Allocating 0 space for a path, this shouldn't happen since we're adding" 
								<< std::endl;
      std::cout << "to paths. Check it out!" << std::endl;
      exit(0);
    }

		// Allocate the new path. This may be longer or shorter 
		// than the old path, depending on how much is being replaced.
    newPath = new PathInterval[pathLengths[readIndex] + newSpace];
			
		// Copy the old unmodified parts of the path into the newly allocated space.
    for (p = 0; p < pathStart; p++) {
      newPath[p] = paths[readIndex][p];
    }
    for (p = pathEnd; p < pathLengths[readIndex]; p++ ) {
      newPath[p + newSpace] = paths[readIndex][p];
      if (paths[readIndex][p].edge >= 0 && 
					paths[readIndex][p].index >= 0) 
				(*edges[paths[readIndex][p].edge].intervals)[paths[readIndex][p].index].pathPos += newSpace;
    }

		// The old path is not needed any more.
    delete[] paths[readIndex];
    paths[readIndex] = newPath;
  }
  return newSpace;
}

void IntervalGraph::CopyNewEdges(int readIndex, int intvEdge, int intvIndex,
																 int pathStart, std::vector<int> &newEdges) {

	// Copy edges from 'newEdges' into the path 'readIndex' starting at position
	// 'pathStart'. 
	// It is assumed that space has been made in the path for 'newEdges'.

	// Intervals are added to these edges, and initilalized as intervals that cover
	// the entire edge.  They might have to be fixed later.
  int e;
  ReadInterval newInterval;
  int curReadPos;
  curReadPos = (*edges[intvEdge].intervals)[intvIndex].readPos;
  int lastInterval;
  int prevEdgeLength, prevVertexSize;
  int prevEdge, prevInterval;
  prevEdge       = intvEdge;
	if (pathStart > 0) {
		prevEdge       = paths[readIndex][pathStart-1].edge;
		prevInterval   = paths[readIndex][pathStart-1].index;
		prevEdgeLength = (*edges[prevEdge].intervals)[prevInterval].length;
		prevVertexSize = vertices[edges[prevEdge].dest].vertexSize;
	}
	else {
		prevEdge = -1;
		prevInterval = -1;
		prevEdgeLength = 0;
		prevVertexSize = 0;
	}

  for (e = 0; e < newEdges.size(); e++ ) {
    /* 
       Record which edge this interval is in, and which pos the edge
       references the interval.
			 
       Assume the interval uses the entire length of the edge.  This 
       may be truncated later if it needs to be in order to conform
       to the positions of the rest of the path.
    */
    newInterval.read    = readIndex;
		//    newInterval.edge    = -1; // Don't store edges for now.
    newInterval.pathPos = pathStart + e;
    newInterval.length  = edges[newEdges[e]].length;
    newInterval.readPos = curReadPos + prevEdgeLength - prevVertexSize;

    /* This path passes through the beginning of the edge. */
    newInterval.edgePos = 0;

    /* Just make sure something strange isn't happening with the new edge.*/
    assert(newInterval.length > 0);

    /* Add this interval to the edge. */
    edges[newEdges[e]].intervals->push_back(newInterval);
    edges[newEdges[e]].multiplicity++;
    /* 
       We've added the interval to the edge, so its index is 
       simply the last one.
    */
			
    /* Make the path reference it's spot in the edge.*/
    paths[readIndex][e + pathStart].edge  = newEdges[e];
    paths[readIndex][e + pathStart].index = edges[newEdges[e]].intervals->size()-1;

    /* Store values to use on the next iteration.*/
    prevInterval = edges[newEdges[e]].intervals->size() - 1;
    prevEdge     = newEdges[e];
    prevEdgeLength = (*edges[prevEdge].intervals)[prevInterval].length;
    prevVertexSize = vertices[edges[prevEdge].dest].vertexSize;
    curReadPos     = newInterval.readPos;
  }
}

int IntervalGraph::ReplacePathRangeForward(int readIndex,
																					 int intvEdge, int intvIndex,
																					 int pathStart, int pathEnd,
																					 std::vector<int> &newEdges) {

	/*
		Given a path 'readIndex', replace a subpath with a different path.  
		The path from (pathStart ... pathEnd] is repalced by the path contained 
		in 'newEdges'.
		The rest of the path is filled in.
		If pathStart == pathEnd, this effectively inserts the path 
		before pathStart.
		
		After replacing the subpath, the lengths of the new path are updated
		so that the end position of the new subpath is 1- the beginning position
		of succeeding path interval.

		Since the path intervals are given, I don't think it's necessary to provide
		intvEdge and intvIndex as parameters, but that needs to be examined later.

		This can be tested with an assert for:
		paths[pathStart].edge == intvEdge  and
		paths[pathStart].index == intvIndex
	*/

  ReplacePathRange(readIndex, intvEdge, intvIndex, pathStart, pathEnd, newEdges);

  /*
    Now update the read and path positions.
  */
  /*
		Update the values to be used on the next iteration.
	*/
  /* If this is the last new edge, offset the length so that 
     the path reaches the next edge on the path.
  */
  int lastNewEdge    = paths[readIndex][pathStart + newEdges.size()-1].edge;
  int lastNewIntv    = paths[readIndex][pathStart + newEdges.size()-1].index;
  int lastNewIntvLength = (*edges[lastNewEdge].intervals)[lastNewIntv].length;
  int lastVertexSize = vertices[edges[lastNewEdge].dest].vertexSize;
  int lastReadPos  = (*edges[lastNewEdge].intervals)[lastNewIntv].readPos;

  int nextEdge         = paths[readIndex][pathStart + newEdges.size()].edge;
  int nextEdgeInterval = paths[readIndex][pathStart + newEdges.size()].index;
	
	
  // IF the replace path joins perfectly with the old path,
  // no interval length adjustments are necessary.
  if (lastReadPos + lastNewIntvLength - lastVertexSize == 
      (*edges[nextEdge].intervals)[nextEdgeInterval].readPos) {
    return 1;
  }


  // Otherwise, it is necessary to adjust the length of the intervals.

	
  int oldPathLength = (*edges[nextEdge].intervals)[nextEdgeInterval].readPos -
    ((*edges[intvEdge].intervals)[intvIndex].readPos +
     (*edges[intvEdge].intervals)[intvIndex].length - 
     vertices[edges[intvEdge].dest].vertexSize);

  //	std::cout << "rplF: oldPathLength: " << oldPathLength << std::endl;
	
  int newPathLength = 0;
  int e;
  for (e = 0; e < newEdges.size(); e++ ) {
    newPathLength += edges[newEdges[e]].length;
    newPathLength -= vertices[edges[newEdges[e]].dest].vertexSize;
  }

  int readPos;
  readPos      = (*edges[intvEdge].intervals)[intvIndex].readPos +
    (*edges[intvEdge].intervals)[intvIndex].length - 
    vertices[edges[intvEdge].dest].vertexSize;


  // now fix the lengths of the intervals
  int edge, intv;
  int edgeLength, intervalLength;
  float remainder, exactIntervalLength;
  remainder = 0;
  //	std::cout << "fixing read positions for " << readIndex << std::endl;
  int endReadPos = (*edges[intvEdge].intervals)[intvIndex].readPos;
  for (e = 0; e < newEdges.size() ; e++) {
    edge = paths[readIndex][pathStart + e].edge;
    intv = paths[readIndex][pathStart + e].index;
    exactIntervalLength = ((((*edges[edge].intervals)[intv].length * 1.0 - 
														 vertices[edges[edge].dest].vertexSize)/ newPathLength) * 
													 oldPathLength + remainder);
    intervalLength = (int) floor(exactIntervalLength);
		
    // Account for accruing round-off error
    remainder = exactIntervalLength - intervalLength;

    // Fix the edge pos to 
    (*edges[edge].intervals)[intv].readPos = readPos;
    assert(readPos >= 0);
    (*edges[edge].intervals)[intv].readPos = readPos;
    (*edges[edge].intervals)[intv].length = intervalLength + vertices[edges[edge].src].vertexSize;
    readPos  += intervalLength;
    assert(readPos >= 0);
  }

  // the hope is that the read pos ends right where the original 
  // path continued.
  if (readPos != (*edges[nextEdge].intervals)[nextEdgeInterval].readPos) {
    /*
      std::cout << "off by a nudge, fixing length by " 
      << readPos - edges[nextEdge].intervals[nextEdgeInterval].readPos
      << std::endl;
    */
    (*edges[edge].intervals)[intv].length -= 
      (readPos - (*edges[nextEdge].intervals)[nextEdgeInterval].readPos);
		
  }
  return 1;
}

int IntervalGraph::ReplacePathRangeReverse(int readIndex,
																					 int intvEdge, int intvIndex,
																					 int pathStart, int pathEnd,
																					 std::vector<int> &newEdges) {
  ReplacePathRange(readIndex, intvEdge, intvIndex, pathStart, pathEnd, newEdges);

  /*
    Now update the read and path positions.
  */
  /* Update the values to be used on the next iteration.*/
  /* If this is the last new edge, offset the length so that 
     the path reaches the next edge on the path.
  */
  int lastNewIntv     = paths[readIndex][pathStart+newEdges.size()-1].index;
  int lastNewEdge     = paths[readIndex][pathStart+newEdges.size()-1].edge;
	
  int nextEdge         = paths[readIndex][pathStart + newEdges.size()].edge;
  int nextEdgeInterval = paths[readIndex][pathStart + newEdges.size()].index;

  // IF the replace path joins perfectly with the old path,
  // no interval length adjustments are necessary.
  // The beginning of the spliced in section of the path is guaranteed
  // to fit with the end of the last part of the old path 
  // before the spliced in section.
  if ((*edges[lastNewEdge].intervals)[lastNewIntv].readPos + 
      (*edges[lastNewEdge].intervals)[lastNewIntv].length -
      vertices[edges[lastNewEdge].dest].vertexSize == 
      (*edges[nextEdge].intervals)[nextEdgeInterval].readPos) {
    return 1;
  }

  // Otherwise, it is necessary to adjust the length of the intervals.
  int oldPathLength = (*edges[nextEdge].intervals)[nextEdgeInterval].readPos -
    ((*edges[intvEdge].intervals)[intvIndex].readPos + 
     (*edges[intvEdge].intervals)[intvIndex].length - 
     vertices[edges[intvEdge].dest].vertexSize);

  int newPathLength = 0;
  int e;
  for (e = 0; e < newEdges.size(); e++ ) {
    newPathLength += edges[newEdges[e]].length;
    newPathLength -= vertices[edges[newEdges[e]].dest].vertexSize;
  }
  int readPos;
  readPos      = (*edges[nextEdge].intervals)[nextEdgeInterval].readPos;

  // now fix the lengths of the intervals, starting at 
  // the END of the new path, so that the length used
  // corresponds to the beginning of the old path
  int edge, intv;
  int edgeLength, intervalLength;
  float remainder, exactIntervalLength;
  remainder = 0;
  int endReadPos = (*edges[intvEdge].intervals)[intvIndex].readPos;
  for (e = newEdges.size()-1; e >= 0 ; e--) {
    edge = paths[readIndex][pathStart + e].edge;
    intv = paths[readIndex][pathStart + e].index;
    exactIntervalLength = ((((*edges[edge].intervals)[intv].length * 1.0 - vertices[edges[edge].src].vertexSize)/ newPathLength) 
													 *oldPathLength + remainder);
    intervalLength = (int) floor(exactIntervalLength);
		
    // Account for accruing round-off error
    remainder = exactIntervalLength - intervalLength;
    readPos  -= intervalLength;

    // Fix the edge pos to 
    (*edges[edge].intervals)[intv].readPos = readPos;
    (*edges[edge].intervals)[intv].length  = intervalLength + vertices[edges[edge].src].vertexSize;
  }
  // back up the last read interval
  readPos -= (*edges[intvEdge].intervals)[intvIndex].length - vertices[edges[intvEdge].dest].vertexSize;
  // the hope is that the read pos ends right where the original 
  // path continued.
  if (readPos != (*edges[intvEdge].intervals)[intvIndex].readPos) {
    int diff = (*edges[intvEdge].intervals)[intvIndex].readPos- readPos;
    (*edges[edge].intervals)[intv].length -= diff;
    (*edges[edge].intervals)[intv].readPos += diff;
  }
  return 1;
}

int IntervalGraph::ReplacePathRange(int readIndex, 
																		int intvEdge, int intvIndex,
																		int pathStart, int pathEnd,
																		std::vector<int> &newEdges) {
  /* 
     Replace part of a path starting at pathStart and ending at pathEnd
     with the edges listed in newEdges.
     Also, add the path intervals to the all edges in newEdges.
     For now, assume that the path passes through the entire edge in newEdges.
  */
	
  /*
    First fix the size of the path if need be.
  */
	
  int newSpace;
  /* 
		 newSpace == 0, no new path needed.
     < 0, must add space to the old path
     > 0, must delete from the old path.
  */
  newSpace = MakeRoomForEdges(readIndex, intvEdge, intvIndex,
															pathStart, pathEnd, newEdges);

  CopyNewEdges(readIndex, intvEdge, intvIndex, pathStart, newEdges);

  pathLengths[readIndex] += newSpace;

  return 1;
}


int IntervalGraph::StoreAlternatePath(int curPathEdge, int nextPathEdge, 
																			std::vector<int> &altPathEdges,
																			int maxSearchLength) {
  std::list<int> altPathEdgeList;
  if (SearchAlternatePath(curPathEdge, nextPathEdge, altPathEdgeList, maxSearchLength)) {
    std::list<int>::iterator listIt;
    altPathEdges.resize(altPathEdgeList.size());
    int i = 0;
    for (listIt = altPathEdgeList.begin();
				 listIt != altPathEdgeList.end();
				 listIt++) {
      altPathEdges[i] = *listIt;
      ++i;
    }
    return 1;
  }
  else
    return 0;
}

int IntervalGraph::SearchAlternatePath(int curPathEdge, int nextPathEdge, 
																			 std::list<int> &altPathEdges,
																			 int maxSearchLength,
																			 int curPathLength) {
  /* Input:
     curPathEdge, curPathIndex - the edge and index of a read interval on that edge.
     nextPathEdge, nextPathIndex - the continuation of that path on some edge that
     may or may not be adjacent to curPathEdge.
  */


  if (curPathEdge == nextPathEdge) {
    return 1;
  }
  else {
    int outEdge, outEdgeIndex;
    int destVertex;
    destVertex = edges[curPathEdge].dest;
    for (outEdgeIndex = vertices[destVertex].FirstOut();
				 outEdgeIndex < vertices[destVertex].EndOut();
				 outEdgeIndex = vertices[destVertex].NextOut(outEdgeIndex)) {
      outEdge = vertices[destVertex].out[outEdgeIndex];
			
			// No long cycles.
      if (edges[curPathEdge].traversed == GraphEdge::Marked)
				continue;
			
			// No very short cycles.
			if (vertices[edges[curPathEdge].dest].traversed = GraphVertex::Marked)
				continue;

      if (edges[curPathEdge].dest == edges[nextPathEdge].src and // make sure this is reached from the right direction
					outEdge == nextPathEdge) {
				return 1;
      }
      else {
				/* The out edge is not the continuation of the path
					 we are looking for.  Continue with dfs for nextPathEdge.
				*/

				int nextEdgeLength = edges[outEdge].length - vertices[edges[outEdge].dest].vertexSize;
				/*
					std::cout << "sap " << altPathEdges.size() << " cur: " << curPathLength << " next " 
					<< nextEdgeLength << " max: " << maxSearchLength <<  " " 
					<< edges[outEdge].index << " " << std::endl;
				*/
				if (maxSearchLength > curPathLength  + nextEdgeLength) {
					altPathEdges.push_back(outEdge);
					edges[curPathEdge].traversed = GraphEdge::Marked;
					vertices[edges[curPathEdge].dest].traversed = GraphVertex::Marked;
					if (SearchAlternatePath(outEdge, nextPathEdge, altPathEdges, 
																	maxSearchLength, 
																	curPathLength +  nextEdgeLength)) {
						edges[curPathEdge].traversed = GraphEdge::NotMarked;
						return 1;
					}
					else {
						/* The search didn't find the nextPathEdge within maxSearchLength.
							 Don't use that edge.
						*/
						altPathEdges.pop_back();
						edges[curPathEdge].traversed = GraphEdge::NotMarked;
					}
				}
      }
    }
    /* 
       All out edges have been tried, and no path works.
       Return 0 for not found.
    */
    return 0;
  }
}

void IntervalGraph::UntraverseReadIntervals() {
  int e, i;
  for (e = 0; e < edges.size(); e++) {
    for (i = 0; i < edges[e].intervals->size(); i++ ) {
      (*edges[e].intervals)[i].traversed = 0;
    }
  }
}

void IntervalGraph::DeleteEdgeListReadIntervals(std::vector<int> &edgeList) {
  int edge;
  for (edge = 0; edge < edgeList.size(); edge++) { 
    DeleteEdgeReadIntervals(edgeList[edge]);
  }
}

void IntervalGraph::DeleteEdgeReadIntervals(int edge) {
  int i;
  for (i = 0; i < edges[edge].intervals->size(); i++ ) {
    DeleteReadInterval((*edges[edge].intervals)[i].read,
											 (*edges[edge].intervals)[i].pathPos);
  }
}
		
void IntervalGraph::DeleteReadInterval(int readIndex, int pathPos) {
  PathInterval *newPath;
  /*
    std::cout << "deleting read interval " << readIndex << " " 
    << pathPos << " " << pathLengths[readIndex] << std::endl;
  */
  assert(pathLengths[readIndex] > 0);
  if (pathLengths[readIndex]-1 > 0) {
    newPath = new PathInterval[pathLengths[readIndex]-1];
    if (pathPos > 0)
      std::copy(&(paths[readIndex][0]), 
								&(paths[readIndex][pathPos]), 
								&(newPath[0]));
    if (pathPos < pathLengths[readIndex]-1) {
      std::copy(&(paths[readIndex][pathPos+1]), 
								&(paths[readIndex][pathLengths[readIndex]]),
								&(newPath[pathPos]));
    }
    /* Update the references from the edge back to the path. */
    int p;
    for (p = pathPos+1; p < pathLengths[readIndex]; p++) {
      if (!IsIntervalMarkedForRemoval(paths[readIndex][p].edge, paths[readIndex][p].index)) {
				(*edges[paths[readIndex][p].edge].intervals)[paths[readIndex][p].index].pathPos--;
				assert((*edges[paths[readIndex][p].edge].intervals)[paths[readIndex][p].index].pathPos >= 0);
      }
    }
    delete[] paths[readIndex];
    paths[readIndex] = newPath;
  }
  else {
    delete[] paths[readIndex];
    paths[readIndex] = NULL;
  }
  pathLengths[readIndex]--;
}

void IntervalGraph::RerouteSimplePathIntervals(int vertex, int inEdge, int outEdge) {

  assert(vertices[vertex].InDegree() == 1);

  // First extend all read intervals that pass through the in edge.
  // Read intervals are sorted by read than position on the read.

  int inInterval, outInterval;
  inInterval = 0;
  outInterval = 0;
  int numInIntervals  = edges[inEdge].intervals->size();
  int numOutIntervals = edges[outEdge].intervals->size();
  int numMerged = 0;
  int numOutIntervalsMarkedForRemoval = 0;

  int inPathPos;
  int readIndex;
  int nextEdge, nextEdgeIntv;
  for (inInterval = 0; inInterval < numInIntervals; inInterval++ ) {
    if (!IsIntervalMarkedForRemoval(inEdge, inInterval)) {
			
      inPathPos = (*edges[inEdge].intervals)[inInterval].pathPos;
      readIndex = (*edges[inEdge].intervals)[inInterval].read;
      if (inPathPos < pathLengths[readIndex]-1) {
				
				nextEdge     = paths[readIndex][inPathPos+1].edge;
				nextEdgeIntv = paths[readIndex][inPathPos+1].index;

				if (!IsIntervalMarkedForRemoval(nextEdge, nextEdgeIntv)) {
					assert(nextEdge == outEdge);
					assert((*edges[inEdge].intervals)[inInterval].readPos + 
								 (*edges[inEdge].intervals)[inInterval].length - 
								 vertices[edges[inEdge].dest].vertexSize == 
								 (*edges[nextEdge].intervals)[nextEdgeIntv].readPos);

					(*edges[inEdge].intervals)[inInterval].length += 
						(*edges[nextEdge].intervals)[nextEdgeIntv].length - 
						vertices[edges[inEdge].dest].vertexSize;
					assert((*edges[inEdge].intervals)[inInterval].length >= 0);
					++numMerged;

					// This out interval has been merged into the in interval.
					// We could remove it from the list, but that's too much
					// memory management.  Just simply mark the start pos of the 
					// out interval as 0
					int read, pathPos;
				
					// Flag this interval as being merged
					(*edges[nextEdge].intervals)[nextEdgeIntv].readPos = -1;
					
					read = (*edges[nextEdge].intervals)[nextEdgeIntv].read;
					pathPos = (*edges[nextEdge].intervals)[nextEdgeIntv].pathPos;

					MarkIntervalForRemoval(nextEdge, nextEdgeIntv);
					DeleteReadInterval(read, pathPos);
				}
      }
    }
  }
	
  // The intervals that remain in 'outEdge' are not part of 'inEdge'
  // They should be added to 'inEdge', with a starting position
  // to offset for the length of 'inEdge'.

  // Count the number of out intervals that will be skipped.
  int remainingOutIntervals = 0;
  for( outInterval = 0; outInterval < numOutIntervals; ++outInterval) {
    // if read pos < 0, this interval has already been merged
    if (IsIntervalMarkedForRemoval(outEdge, outInterval)) {
      numOutIntervalsMarkedForRemoval++;
    }
    else 
      remainingOutIntervals++;
  }
			 
  assert(numOutIntervals == numOutIntervalsMarkedForRemoval + remainingOutIntervals);

  if (numInIntervals + numOutIntervals == 0) {
    edges[inEdge].intervals->clear();
  }
  else {
    edges[inEdge].intervals->resize(numInIntervals + remainingOutIntervals);
    outInterval = 0;
    int appendedIntervals = 0;
    int outIntervalRead, outIntervalPos;
    for( outInterval = 0; outInterval < numOutIntervals; ++outInterval) {
      // if read pos < 0, this interval has already been merged
      if ((*edges[outEdge].intervals)[outInterval].readPos >= 0) {
				if (!IsIntervalMarkedForRemoval(outEdge, outInterval)) {
					(*edges[inEdge].intervals)[numInIntervals + appendedIntervals].read =
						(*edges[outEdge].intervals)[outInterval].read;

					(*edges[inEdge].intervals)[numInIntervals + appendedIntervals].readPos =
						(*edges[outEdge].intervals)[outInterval].readPos;

					(*edges[inEdge].intervals)[numInIntervals + appendedIntervals].length =
						(*edges[outEdge].intervals)[outInterval].length;

					(*edges[inEdge].intervals)[numInIntervals + appendedIntervals].edgePos =
						edges[inEdge].length + (*edges[outEdge].intervals)[outInterval].edgePos - vertexSize;

					(*edges[inEdge].intervals)[numInIntervals + appendedIntervals].pathPos =
						(*edges[outEdge].intervals)[outInterval].pathPos;
					assert((*edges[inEdge].intervals)[numInIntervals + appendedIntervals].pathPos >= 0);

					/* 
						 Update the path to reference inEdge, and the new slot in inEdge.
					*/
					outIntervalRead = (*edges[outEdge].intervals)[outInterval].read;
					outIntervalPos  = (*edges[outEdge].intervals)[outInterval].pathPos;
					paths[outIntervalRead][outIntervalPos].edge  = inEdge;
					paths[outIntervalRead][outIntervalPos].index = numInIntervals + appendedIntervals;

					++appendedIntervals;
				}
				else {
					std::cout << "Caution!!! interval: " << outEdge << " " << outInterval 
										<< " is marked for removal, and I should have removed everything like that " 
										<< std::endl;
				}
      }
    }
    // sanity check
    //		assert(appendedIntervals == numOutIntervals - numMerged - numOutIntervalsMarkedForRemoval);
    assert(appendedIntervals == remainingOutIntervals);
  }
}

void IntervalGraph::UpdatePathEdges(std::vector<int> &edgesToRemove) {
  /* 
     Input: a list of edges to remove.
     Result: paths that reference an edge that is not removed
     have that edge packed, so if there are edges 1, 2, and 3, 
     and edge 2 is deleted, paths that reference edge 3 are updated
     to reference 2.
  */
	
  // Nothing needs to be done if nothing is removed.
  if (edgesToRemove.size() == 0) 
    return;

  int edge;
  int numRemovedEdges = 0;
  for (edge = 0; edge < edges.size(); edge++) {
    if (numRemovedEdges < edgesToRemove.size() and
				edge == edgesToRemove[numRemovedEdges]) {
      ++numRemovedEdges;
    }
    else {
      int i;
      int read;
      int pathPos;
      for (i = 0; i < edges[edge].intervals->size(); i++ ) {
				if (!IsIntervalMarkedForRemoval(edge,i)) {
					read = (*edges[edge].intervals)[i].read;
					pathPos = (*edges[edge].intervals)[i].pathPos;
					assert(read >= 0);
					assert(read < paths.size());
					assert(pathPos < pathLengths[read]);
					assert(pathPos >= 0);
					assert(paths[read][pathPos].edge >= 0);
					assert(paths[read][pathPos].index >= 0);
					assert(paths[read][pathPos].edge == edge);
					assert(paths[read][pathPos].edge - numRemovedEdges >= 0);
					paths[read][pathPos].edge -= numRemovedEdges;
				}
      }
    }
  }
}

void IntervalGraph::Prune(std::vector<int> &verticesToRemove,
													std::vector<int> &edgesToRemove) {

  std::sort(edgesToRemove.begin(), edgesToRemove.end());
  std::sort(verticesToRemove.begin(), verticesToRemove.end());
 
  // Do a sanity check on the edges to remove. If any single edge
  // is in the to remove list, then it's balanced edge should be in as well
  int re;
  int balancedEdge;
  std::vector<int>::iterator reIt;
  for (re = 0; re < edgesToRemove.size(); re++ ){
    balancedEdge = edges[edgesToRemove[re]].balancedEdge;
    // We don't want to do a sanity check on edges that
    // do not have balanced parts.
    
    if (balancedEdge >= 0 and
				std::binary_search(edgesToRemove.begin(), edgesToRemove.end(), balancedEdge) == 0) {
      std::cout << "ERROR! Removing edge "<< edgesToRemove[re] << " but not balanced edge " 
								<< balancedEdge << std::endl;
    }
  }
  if (verticesToRemove.size() > 0) {
    /*
      std::cout << "Deleting " << verticesToRemove.size() 
      << " vertices out of " << vertices.size()
      << std::endl;
    */
    RemoveVertexList(verticesToRemove);
    //    DeleteElementsFromList(vertices, verticesToRemove);
  }
  if (edgesToRemove.size() > 0) {
    RemoveEdgeList(edgesToRemove);
  }
  RemoveTruncatedPathIntervals();
  CheckEdges(vertices, edges);
  CheckBalance();
}

void IntervalGraph::RemoveVertexList(std::vector<int> &verticesToRemove) {
  int v;
  int newV, removedV;
	
  newV = 0;
  removedV = 0;
  int inEdgeIndex, inEdge, outEdgeIndex, outEdge;
  int removedVertices = 0;
  for (v = 0; v < vertices.size(); v++) {
    if (removedV < verticesToRemove.size() and
				v == verticesToRemove[removedV]) {
      while (v < vertices.size() and 
						 removedV < verticesToRemove.size() and 
						 v == verticesToRemove[removedV]) {
				assert(removedV < verticesToRemove.size());
				++removedV;
			}
      ++removedVertices;
    }
    else {
      vertices[newV] = vertices[v];
      for (inEdgeIndex = vertices[newV].FirstIn();
					 inEdgeIndex != vertices[newV].EndIn();
					 inEdgeIndex = vertices[newV].NextIn(inEdgeIndex)) {
				inEdge = vertices[newV].in[inEdgeIndex];
				edges[inEdge].dest = newV;
      }
      for (outEdgeIndex = vertices[newV].FirstOut();
					 outEdgeIndex != vertices[newV].EndOut();
					 outEdgeIndex = vertices[newV].NextOut(outEdgeIndex)) {
				outEdge = vertices[newV].out[outEdgeIndex];
				edges[outEdge].src = newV;
      }
      newV++;
    }
  }
  if (removedVertices < vertices.size())
    vertices.resize(vertices.size() - removedVertices);
  else
    vertices.clear();
}


void IntervalGraph::RemoveEdgeList(std::vector<int> &edgesToRemove) {
  int e, newE, removedE;
  newE = 0;
  removedE = 0;
  int src, srcOutIndex, dest, destInIndex;
  int i;
  int removedEdges = 0;
  for (e = 0; e < edges.size(); e++ ) {
    if (removedE < edgesToRemove.size() and
				e == edgesToRemove[removedE]) {
      ++removedEdges;
      while (e < edges.size() and 
						 removedE < edgesToRemove.size() and
						 e == edgesToRemove[removedE]) {
				removedE++;
      }
    }
    else {
			if (newE != e) {
				
      edges[newE] = edges[e];
      src = edges[newE].src;
      srcOutIndex = vertices[src].LookupOutIndex(e);
      assert(srcOutIndex >= 0);
      vertices[src].out[srcOutIndex] = newE;

      dest = edges[newE].dest;
      destInIndex = vertices[dest].LookupInIndex(e);
      assert(destInIndex >= 0);
      vertices[dest].in[destInIndex] = newE;

      int balE;
      balE = edges[newE].balancedEdge;
      if (balE != e) {
				edges[balE].balancedEdge = newE;
      }
      else {
				edges[newE].balancedEdge = newE;
      }

      // update the paths to 
      for (i= 0; i < edges[newE].intervals->size(); i++) { 
				assert((*edges[newE].intervals)[i].read >= 0);
				assert((*edges[newE].intervals)[i].pathPos >= 0);
				paths[(*edges[newE].intervals)[i].read][(*edges[newE].intervals)[i].pathPos].edge = newE;
      }
			}
      ++newE;
    }
  }
  if (removedEdges < edges.size()) {
    edges.resize(edges.size() - removedEdges);
  }
  else
    edges.clear();
}

void ErodeLeavesFunctor::operator()(int vertexIndex) {
  vertexIndex;
  int inDegree = (*vertices)[vertexIndex].InDegree();
  int outDegree = (*vertices)[vertexIndex].OutDegree();
  int destVertex, srcVertex;
  int e;
  int balancedIndex;
  int balancedDestVertex, balancedSrcVertex;
  int i;
  if ( outDegree == 0 and inDegree > 0) {
    int inEdge, inEdgeIndex;
    inEdge = (*vertices)[vertexIndex].FirstIn();
    int allShortSources = 1;
    while (inEdge < (*vertices)[vertexIndex].EndIn() and
					 allShortSources) {
      inEdgeIndex = (*vertices)[vertexIndex].in[inEdge];
      //      if ((*edges)[inEdgeIndex].length >= minLength) {
      if (!(*edges)[inEdgeIndex].IsShort(minLength)) {
				allShortSources = 0;
      }
      inEdge = (*vertices)[vertexIndex].NextIn(inEdge);
    }    
    if (allShortSources) {
      inEdge = (*vertices)[vertexIndex].FirstIn();
      while (inEdge < (*vertices)[vertexIndex].EndIn()) {
				inEdgeIndex = (*vertices)[vertexIndex].in[inEdge];
				srcVertex = (*edges)[inEdgeIndex].src;
				if ((*edges)[inEdgeIndex].IsShort(minLength) or 
						(*edges)[inEdgeIndex].flagged == GraphEdge::Marked) {
					(*edges)[inEdgeIndex].flagged = GraphEdge::Marked;
					erodedEdgeList.push_back(inEdgeIndex);
					//					(*vertices)[srcVertex].EraseOutEdge(inEdgeIndex);
					if ((*vertices)[vertexIndex].flagged != GraphVertex::Marked)
						erodedVertexList.push_back(vertexIndex);
	  
					(*vertices)[vertexIndex].flagged = GraphVertex::Marked;
				}
				inEdge = (*vertices)[vertexIndex].NextIn(inEdge);
      }
    }
  }

  if ( inDegree == 0 and outDegree > 0) {
    int outEdge, outEdgeIndex;
    int allShortSinks = 1;
    outEdge = (*vertices)[vertexIndex].FirstOut();
    while (outEdge < (*vertices)[vertexIndex].EndOut() and
					 allShortSinks ) {
      outEdgeIndex = (*vertices)[vertexIndex].out[outEdge];
      //      if ((*edges)[outEdgeIndex].length >= minLength ) 
      if (!(*edges)[outEdgeIndex].IsShort(minLength)) {
				allShortSinks = 0;
      }
      outEdge = (*vertices)[vertexIndex].NextOut(outEdge);
    }
    if (allShortSinks) {
      outEdge = (*vertices)[vertexIndex].FirstOut();
      while (outEdge < (*vertices)[vertexIndex].EndOut()) {
				outEdgeIndex = (*vertices)[vertexIndex].out[outEdge];
				destVertex = (*edges)[outEdgeIndex].dest;
				if ((*edges)[outEdgeIndex].IsShort(minLength) or
						(*edges)[outEdgeIndex].flagged == GraphEdge::Marked) {
					// Signal these edges and vertices as GONE!
					(*edges)[outEdgeIndex].flagged = GraphEdge::Marked;
					erodedEdgeList.push_back(outEdgeIndex);
					//					(*vertices)[destVertex].EraseInEdge(outEdgeIndex);
					if ((*vertices)[vertexIndex].flagged != GraphVertex::Marked) 
						erodedVertexList.push_back(vertexIndex);
					(*vertices)[vertexIndex].flagged = GraphVertex::Marked;
				}
				outEdge = (*vertices)[vertexIndex].NextOut(outEdge);
      }
    }

    // Do a sanity check on the balanced edges
    balancedIndex = (*edges)[outEdgeIndex].balancedEdge;
    balancedDestVertex = (*edges)[balancedIndex].dest;
    /*
      if (balancedIndex != outEdgeIndex and balancedDestVertex > vertexIndex)
      assert((*vertices)[balancedDestVertex].OutDegree() == 0 );
    */


  }
  if (inDegree == 0 and outDegree == 0) {
    (*vertices)[vertexIndex].flagged = GraphVertex::Marked;
    erodedVertexList.push_back(vertexIndex);
  }
}


void IntervalGraph::RemoveEdgeAndMarkPathsForRemoval(int edge,
																										 std::vector<int> &removedVertices) {

  MarkPathsThroughEdgeForRemoval(edge);
  RemoveEdge(edge, removedVertices);
}


void IntervalGraph::RemoveEdgeAndMarkIntervalsForRemoval(std::vector<int> &edgeList,
																												 std::vector<int> &removedVertices) {
  int e;
  for (e = 0; e < edgeList.size(); e++ ) {
    MarkIntervalsInEdgeForRemoval(edgeList[e]);
    RemoveEdge(edgeList[e], removedVertices);
  }
}

void IntervalGraph::RemoveEdgeAndMarkIntervalsForRemoval(int edge,
																												 std::vector<int> &removedVertices) {

  MarkIntervalsInEdgeForRemoval(edge);
  RemoveEdge(edge, removedVertices);
}


void IntervalGraph::RemoveEdge(int edge, std::vector<int> &removedVertices) {
  int sourceVertex, destVertex;
  int outIndex, inIndex;
  sourceVertex = edges[edge].src;
  destVertex   = edges[edge].dest;
  outIndex = vertices[sourceVertex].LookupOutIndex(edge);
  assert(outIndex >= 0);
  vertices[sourceVertex].out[outIndex] = -1;

  inIndex  = vertices[destVertex].LookupInIndex(edge);
  assert(inIndex >= 0);
  vertices[destVertex].in[inIndex] = -1;

  if (vertices[sourceVertex].OutDegree() == 0 and 
      vertices[sourceVertex].InDegree() == 0) {
    //    std::cout << "adding " << sourceVertex  << std::endl;
    removedVertices.push_back(sourceVertex);
  }
    
  if (vertices[destVertex].InDegree() == 0 and
      vertices[destVertex].OutDegree() == 0) {
    //    std::cout << "adding " << destVertex << std::endl;
    removedVertices.push_back(destVertex);
  }
  edges[edge].src = -1;
  edges[edge].dest = -1;
  /*  RemoveAllPathsThroughEdge(edge);*/
}

void IntervalGraph::RemoveAllButMST() {
  int e;
  int v;
  GraphAlgo::CalcMST(vertices, edges);  
  std::vector<int> mstEdges;
  std::cout << "mst: ";
  for (e = 0; e < edges.size(); e++ ) {
    if (edges[e].mst == GraphAlgo::MSTIn and 
				edges[edges[e].balancedEdge].mst != GraphAlgo::MSTIn) {
      // Fix the graph to add back balanced edges
      edges[edges[e].balancedEdge].mst = GraphAlgo::MSTIn;
    }
    if (edges[e].mst == GraphAlgo::MSTIn) {
      mstEdges.push_back(e);
    }
  }
  std::cout << std::endl;
  if (CheckBalancedEdgeList(edges, mstEdges) ) {
    std::cout << "mst edges are BALANCED " << std::endl;
  }
  else {
    std::cout << "mst edges are NOT balanced " << std::endl;
  }

  std::vector<int> removedVertices, removedEdges;
  for (e = 0; e < edges.size(); e++ ) {
    if (edges[e].mst != GraphAlgo::MSTIn) {
      RemoveEdge(e, removedVertices);
      removedEdges.push_back(e);
    }
  }
  Prune(removedVertices, removedEdges);

  CondenseSimplePaths();

  Erode(60);
}



void IntervalGraph::Erode(int minEdgeLength) {
  ErodeLeavesFunctor erodeLeaves;

  erodeLeaves.vertices = &vertices;
  erodeLeaves.edges    = &edges;
  erodeLeaves.minLength = minEdgeLength;
  std::vector<int> erodedEdgeList, erodedVertexList;
  int iteration = 0;
  std::vector<int> skippedEdges, skippedVertices;
  int e;
  do {
    ++iteration;
    erodeLeaves.Clear();
    erodedVertexList.clear();
    erodedEdgeList.clear();
    Unmark();
    CheckGraphStructureBalance();
    TraverseRandomAccess(vertices, edges, erodeLeaves);
    int e, i;
    for (e = 0; e < edges.size();e++ ){ 
      for (i = 0; i < edges[e].intervals->size(); i++) { 
				assert((*edges[e].intervals)[i].pathPos >= 0);
      }
    }
    std::sort(erodeLeaves.erodedEdgeList.begin(),
							erodeLeaves.erodedEdgeList.end());
    int e2;
		/*
			int balancedFound;
			for (e = 0; e < erodeLeaves.erodedEdgeList.size(); e++ ) {
      balancedFound = 0;
      for (e2 = 0; e2 < erodeLeaves.erodedEdgeList.size(); e2++ ) {
			if (erodeLeaves.erodedEdgeList[e2] == edges[erodeLeaves.erodedEdgeList[e]].balancedEdge) {
			balancedFound = 1;
			break;
			}
      }
      if (!balancedFound) {
			std::cout << "error: edge list at e: " << e << " " << erodeLeaves.erodedEdgeList[e] << std::endl;
      }
			}
		*/
		//    std::cout << "before removing edges  " << std::endl;
    CheckEdges(vertices, edges);
    for (e = 0; e < erodeLeaves.erodedEdgeList.size(); e++ ) {
      if (e == 0 or 
					e > 0 and erodeLeaves.erodedEdgeList[e] != erodeLeaves.erodedEdgeList[e-1]) {
				DeleteEdgeReadIntervals(erodeLeaves.erodedEdgeList[e]);
				RemoveEdge(erodeLeaves.erodedEdgeList[e], erodedVertexList);
      }
    }
    CheckEdges(vertices, edges);
    CheckGraphStructureBalance();

    Prune(erodedVertexList, erodeLeaves.erodedEdgeList);
    CheckEdges(vertices, edges);
    std::cout << "iteration: " << iteration  << " "
							<< erodeLeaves.erodedVertexList.size() << " " 
							<< erodeLeaves.erodedEdgeList.size() << std::endl;
    skippedVertices.clear();
    skippedEdges.clear();
    //    CheckBalance(edges);
		
    CheckGraphStructureBalance();
    int numCondensedEdges = CondenseSimplePaths();
    std::cout << "After eroding " << numCondensedEdges 
							<< " edges were condensed."<<std::endl;

    // Do a sanity check.  I might turn this off in non-debugging mode.
    CheckBalance();
    //    ClearMST();
  } while (erodedEdgeList.size() > 0);

	RemoveEmptyEdges();
  CheckAllPathsBalance(1);
  std::cout << "end of erode " << std::endl;
  CheckGraphStructureBalance();
	
}

void IntervalGraph::CheckBalance() {
  int e;
  int balE;
  for (e = 0; e < edges.size(); e++ ) {
    balE = edges[e].balancedEdge;
    if (edges[balE].balancedEdge != e) {
      std::cout << "edges " << e <<" " << balE << " are not balanced " << std::endl;
    }
    else if (edges[balE].intervals->size() != edges[e].intervals->size()) {
      std::cout << "edges " << e << " (" << edges[e].index << ") " 
								<< balE << " ( " << edges[balE].index 
								<< ")  should have equal multiplicity " 
								<< edges[balE].intervals->size() << " " <<  edges[e].intervals->size() 
								<< " indices: " << edges[e].index << " " << edges[balE].index 
								<< std::endl;
    }
  }
}

void IntervalGraph::ClearMST() {
  int e;
  for (e = 0; e < edges.size(); e++ ) {
    edges[e].mst = GraphAlgo::MSTOut;
  }
}

int IntervalGraph::RemoveAllPathsThroughEdge(int edge) {
  int interval = 0;
  int prevSize;
  std::vector<int> pathEdges, pathIntervalIndices;
  //  std::cout << "removing paths through " << edge << std::endl;

  while (edges[edge].intervals->size() > 0)  {  
    // clean up from previous run
    pathEdges.clear();
    pathIntervalIndices.clear();

    // find the path that contains the 0'th interval in edges[e].intervals  
    prevSize = edges[edge].intervals->size();
    TracePath(edge, 0, pathEdges, pathIntervalIndices);  
    // remove it  
    MarkPathForRemoval(pathEdges,pathIntervalIndices);
    // sanity check, the size of the interval set shrank by at least 1
    assert(edges[edge].intervals->size() < prevSize);
  }
}


int IntervalGraph::TracePathReverse(int curEdge, int curIndex, int &prevEdge, int &prevIndex) {
  int inEdgeIndex, inEdge;
  prevEdge = -1;
  prevIndex = -1;
  int sourceVertex;
  sourceVertex = edges[curEdge].src;
  //  std::cout << "tracing path back through " << vertices[sourceVertex].InDegree() << std::endl;
  if (IsIntervalMarkedForRemoval(curEdge, curIndex))
    return 0;

  for (inEdgeIndex = vertices[sourceVertex].FirstIn();
       inEdgeIndex < vertices[sourceVertex].EndIn();
       inEdgeIndex = vertices[sourceVertex].NextIn(inEdgeIndex)) {
    inEdge = vertices[sourceVertex].in[inEdgeIndex];
    prevIndex = TraceReadIntervalReverse(edges[curEdge], curIndex, edges[inEdge], vertexSize);
    if ( prevIndex >= 0) {
      prevEdge = inEdge;
      return 1;
    }
  }
  return (inEdgeIndex < vertices[sourceVertex].EndIn());
}

int IntervalGraph::RemoveMarkedIntervals() {
  int e, i;
  int numRemoved;
  /*
    This is called after various paths in the graph have been
    marked for removal.  This removes those paths from the graph,
    and packs the remaining lists of paths.
  */
  for (e = 0; e < edges.size(); e++) {
    numRemoved = 0;
    for (i = 0 ; i < edges[e].intervals->size(); i++ ) {
      if (IsIntervalMarkedForRemoval(e, i)) 
				numRemoved++;
      else {
				int pathPos = (*edges[e].intervals)[i].pathPos;
				assert(pathPos >= 0);
				paths[(*edges[e].intervals)[i].read][pathPos].index = i - numRemoved;
				(*edges[e].intervals)[i-numRemoved] = (*edges[e].intervals)[i];
      }
    }
    if (numRemoved < (*edges[e].intervals).size())
      (*edges[e].intervals).resize(edges[e].intervals->size() - numRemoved);
    else
      edges[e].intervals->clear();
  }
}

int IntervalGraph::MarkPathForRemoval(std::vector<int> &pathEdges,
																			std::vector<int> &pathIndices) {
  int i;
  for (i = 0; i < pathEdges.size(); i++ ) {
    assert(pathIndices[i] < edges[pathEdges[i]].intervals->size());
    MarkIntervalForRemoval(pathEdges[i], pathIndices[i]);
  }
}

int IntervalGraph::RemovePath(std::vector<int> &pathEdges,
															std::vector<int> &pathIndices) {
  int i, j;
  for (i = 0; i < pathEdges.size(); i++ ) {
    assert(pathIndices[i] < edges[pathEdges[i]].intervals->size());
    edges[pathEdges[i]].intervals->erase(edges[pathEdges[i]].intervals->begin() + pathIndices[i]);
    // Now fix any indices of intervals that pass through this edge again.  If they do
    // the size of the interval list is smaller, so we delete one earlier.
    
    // This is a slightly slow way of doing this, but oh well, these lists are small
    for (j = i+1; j < pathEdges.size(); j++ ) {
      if (pathEdges[i] == pathEdges[j] and pathIndices[j] > pathIndices[i])
				pathIndices[j]--;
    }
  }
}

void IntervalGraph::AssignIntervalPathOrder() {
  int e, i, p;
  std::vector<int> pathEdges, pathIndices;
  pathLengths.resize(maxReadIndex+ 1);
  std::fill(pathLengths.begin(), pathLengths.end(), 0);
  paths.resize(maxReadIndex+1);
  int readIndex;
  std::cout << "assigning path orders " << std::endl;
  for (e = 0; e < edges.size(); e++) {
    for (i = 0; i < edges[e].intervals->size(); i++) {
      if ((*edges[e].intervals)[i].pathPos == -1) {

				TracePath(e, i, pathEdges, pathIndices);

				assert(pathEdges.size() > 0);
				readIndex = (*edges[e].intervals)[i].read;
				pathLengths[readIndex] = pathEdges.size();
				paths[readIndex] = new PathInterval[pathEdges.size()];
				
				for (p = 0; p < pathEdges.size(); p++ ) {
					(*edges[pathEdges[p]].intervals)[pathIndices[p]].pathPos = p;
					paths[readIndex][p].edge = pathEdges[p];
					paths[readIndex][p].index = pathIndices[p];
				}
				
				pathEdges.clear();
				pathIndices.clear();
      }
    }
  }
  std::cout << "done." << std::endl;
}




int IntervalGraph::TracePath(int curEdge, int curIndex, 
														 std::vector<int> &pathEdges,
														 std::vector<int> &pathIndices) {
  int curEdgeCopy = curEdge;
  int curIndexCopy = curIndex;
  int nextEdge, nextIndex;
  int prevEdge = -1;
  int prevIndex = -1;
  int printInterval = 0;
  if (IsIntervalMarkedForRemoval(curEdge, curIndex))
    return 0;

  /* 
     Starting at some random point in a path (all paths through an edge) 
     follow the path backwards (to the beginning) and forwards (to the end).
     Store the paths.
  */		 
  StorePathReverse(curEdge, curIndex, pathEdges, pathIndices);
  curEdge = curEdgeCopy;
  curIndex = curIndexCopy;
  (*edges[curEdge].intervals)[curIndex].traversed = 1;
  pathEdges.push_back(curEdge);
  pathIndices.push_back(curIndex);

  StorePathForwards(curEdge, curIndex, pathEdges, pathIndices);
	
  if (printInterval) {
    int i;
    for (i = 0; i < pathEdges.size(); i++) {
      std::cout << pathEdges[i] << " " << pathIndices[i] << std::endl;
    }
  }
}

int IntervalGraph::CalcEdgeMultiplicityStats(float &intervalsPerNucleotide) {

	int totalLength; 		
	int totalIntervals;
	int e,i;
	totalIntervals = 0;
	totalLength    = 0;
	for (e = 0; e < edges.size(); e++) {
//		for (i = 0; i < edges[e].intervals.size(); i++ ) {
//			if (edges[e].intervals[i].readPos == 0 or
//					edges[e].intervals[i].length == edges[e].length) {
//				totalIntervals ++;
//			}
//	}
    totalIntervals += edges[e].intervals->size();
		totalLength    += edges[e].length;
	}
	intervalsPerNucleotide =  totalIntervals / (1.0*totalLength);
}

int IntervalGraph::RemoveEmptyEdges() {
	int e;
	std::vector<int> edgesToRemove, verticesToRemove;
	for (e = 0; e < edges.size() ; e++ ) {
		if (edges[e].intervals->size() == 0) {
			edgesToRemove.push_back(e);
			RemoveEdge(e, verticesToRemove);
		}
	}
	Prune(verticesToRemove, edgesToRemove);
}

int IntervalGraph::RemoveLowCoverageEdges(float lowCoverageStddev) {
  int e;
  std::vector<int> edgesToRemove, verticesToRemove;
  int removedAnEdge = 1;
  int iter = 0;
  int prevRemoveSize;
  /* 
     Removing some edges lowers the multiplicity of others.  
     Keep removing edges until none are removed (removedAnEdge==0).
  */
  int srcVertex, destVertex;

	float avgMultip, stddevMultip;
	CalcEdgeMultiplicityStats(avgMultip);
	std::cout << "got average multip: " << avgMultip << std::endl;
  while (removedAnEdge) {
    ++iter;
    edgesToRemove.clear();
    verticesToRemove.clear();
    do {
      UntraverseReadIntervals();
      prevRemoveSize = edgesToRemove.size();
      int removedEdge = 0;
      for (e = 0; e < edges.size(); e++ ) {
				if (edgesToRemove.size() > 0 and 
						removedEdge < edgesToRemove.size() and 
						e == edgesToRemove[removedEdge]) 
					++removedEdge;
				else {
					int lowCov = 1;
					if (edges[e].IsUnexpectedlyLowCoverage(avgMultip, 
																								 lowCoverageStddev, 
																								 (int)(vertexSize*1.2))
							or edges[e].intervals->size() < lowCov) {
						// The edge doesn't have enough reads mapped to it.
						// Maybe remove it.
						
						// Don't keep empty edges
						if (edges[e].intervals->size() == 0) {
							edgesToRemove.push_back(e);
						}
						// Make sure that removing this edge doesn't
						// cut the graph in two
						else if (!RemovingEdgeCutsGraph(e)  || edges[e].intervals->size() < lowCov) {
							// Check to see if this edge creates a short cycle. 
							// We trust those edges, and do special cycle-straightening later on.
							int doe, doi;
							int formsCycle = 0;
							for (doi = vertices[edges[e].dest].FirstOut();
									 doi < vertices[edges[e].dest].EndOut();
									 doi = vertices[edges[e].dest].NextOut(doi)) {
								doe = vertices[edges[e].dest].out[doi];
								if (edges[doe].dest == edges[e].src) {
									//std::cout << "edge " << e << " forms a short cycle"
									// << edges[e].length << std::endl;
									formsCycle = 1;
								}
							}
							if (!formsCycle) {
								edgesToRemove.push_back(e);
							}
						}
					}
				}
			}
      std::cout << "Remove low coverage, iter: " << iter << " " 
								<< edgesToRemove.size() << " edges " << std::endl;
      std::sort(edgesToRemove.begin(), edgesToRemove.end());
    } while (prevRemoveSize < edgesToRemove.size());

    for (e = 0; e < edgesToRemove.size(); e++) {
      RemoveEdgeAndMarkPathsForRemoval(edgesToRemove[e], verticesToRemove);
    }

    // Remove all intervals that were marked
    // when an edge was axed
    RemoveMarkedIntervals();
    Prune(verticesToRemove, edgesToRemove);
    int numCondensed = CondenseSimplePaths();
    std::cout << "After removing low coverage edges, condensed " 
							<< numCondensed << " edges." << std::endl;
    UntraverseReadIntervals();
    RemoveMarkedIntervals();
		if (vertices.size() > 0) 
			Erode(vertices[0].vertexSize * 3);
												 
    if (edgesToRemove.size() > 0)
      removedAnEdge = 1;
    else
      removedAnEdge = 0;
  }
  return 1;
}


int IntervalGraph::StorePathReverse(int curEdge, int curIndex,
																		std::vector<int> &pathEdges,
																		std::vector<int> &pathIndices) {
  int prevEdge, prevIndex;
  do {
    if (IsIntervalMarkedForRemoval(curEdge, curIndex))
      break;
    TracePathReverse(curEdge, curIndex, prevEdge, prevIndex);
    if (prevEdge >= 0) {
      (*edges[prevEdge].intervals)[prevIndex].traversed = 1;
      pathEdges.insert(pathEdges.begin(),prevEdge);
      pathIndices.insert(pathIndices.begin(),prevIndex);
    }
    curEdge = prevEdge;
    curIndex = prevIndex;
  } while (curEdge >= 0 and curIndex >= 0);
  return pathEdges.size();
}

int IntervalGraph::StorePathForwards(int curEdge, int curIndex,
																		 std::vector<int> &pathEdges,
																		 std::vector<int> &pathIndices) {
  int nextEdge, nextIndex;
  do {
    // Don't try and add the current edge if it is already marked
    // for removal.
    if (IsIntervalMarkedForRemoval(curEdge, curIndex))
      break;

    TracePathForwards(curEdge, curIndex, nextEdge, nextIndex);
    if (nextEdge >= 0 and nextIndex >= 0) {
      (*edges[nextEdge].intervals)[nextIndex].traversed = 1;
      pathEdges.push_back(nextEdge);
      pathIndices.push_back(nextIndex);
    }
    curEdge = nextEdge;
    curIndex = nextIndex;
  } while (curEdge >= 0 and curIndex >= 0);
  return pathEdges.size();
}

int IntervalGraph::TracePathForwards(int curEdge, int curIndex, int &nextEdge, int &nextIndex) {
  int outEdgeIndex, outEdge;
  nextEdge = -1;
  nextIndex = -1;
  int destVertex;
  //  std::cout << "tracing path forwards through " << vertices[destVertex].OutDegree() << std::endl;
  // if the edge is a self-loop, it's possible the path continues on the same edge
  destVertex = edges[curEdge].dest;
  if (IsIntervalMarkedForRemoval(curEdge, curIndex))
    return 0;

  if (curIndex < edges[curEdge].intervals->size()-1 and
      (*edges[curEdge].intervals)[curIndex].read == (*edges[curEdge].intervals)[curIndex+1].read and
      (*edges[curEdge].intervals)[curIndex].readPos + 
      (*edges[curEdge].intervals)[curIndex].length - vertices[destVertex].vertexSize
      == (*edges[curEdge].intervals)[curIndex+1].readPos) {
    nextEdge = curEdge;
    nextIndex = curIndex + 1;
  }

  // the next index isn't the succeeding index, so it's in the next edge
  destVertex = edges[curEdge].dest;
  for (outEdgeIndex = vertices[destVertex].FirstOut();
       outEdgeIndex < vertices[destVertex].EndOut();
       outEdgeIndex = vertices[destVertex].NextOut(outEdgeIndex)) {
    outEdge = vertices[destVertex].out[outEdgeIndex];
    nextIndex = TraceReadIntervalForward(edges[curEdge], curIndex, edges[outEdge], vertices[destVertex].vertexSize);
		if (curEdge == outEdge and 
				nextIndex == curIndex) {
			std::cout << "TRACING stayed in the same spot, that's not good!\n";
			exit(1);
			nextEdge = -1;
			return 0;
		}
    if ( nextIndex >= 0) {
      nextEdge = outEdge;
      return 1;
    }
  }
  return outEdgeIndex < vertices[destVertex].EndOut();
}

template<typename V, typename E>
class FindSourcesAndSinksFunctor {
public:
  std::vector<int> sources;
  std::vector<int> sinks;
  std::vector<V> *vertices;
  std::vector<E> *edges;
  void Clear() {
    sources.clear();
    sinks.clear();
  }
  void operator()(int vertex) {
    int inDegree, outDegree;
    inDegree = (*vertices)[vertex].InDegree();
    outDegree = (*vertices)[vertex].OutDegree();
    if (inDegree == 1 and outDegree == 0)
      sinks.push_back(vertex);

    if (inDegree == 0 and outDegree == 1) 
      sources.push_back(vertex);

    return;
  }
};


void IntervalGraph::FindSourcesAndSinks(std::vector<int> &sources,
																				std::vector<int> &sinks) {

  Unmark();
  FindSourcesAndSinksFunctor<TVertex, TEdge> findSourceSink;
  findSourceSink.vertices = &vertices;
  findSourceSink.edges    = &edges;
  int vertex;
  for (vertex = 0; vertex < vertices.size(); vertex++ ) {
    if (vertices[vertex].marked == GraphVertex::Marked)
      continue;
    
    // reset any previous result of sources and sinks
    findSourceSink.Clear();
    TraverseDFS(vertices, edges, vertex, findSourceSink);
    sources.insert(sources.end(), 
									 findSourceSink.sources.begin(), findSourceSink.sources.end());
    sinks.insert(sinks.end(),
								 findSourceSink.sinks.begin(), findSourceSink.sinks.end());
  }
}
					

void IntervalGraph::TraceSourceToSinkPaths(std::vector<int> &edgeTraversalCount) {
  // reset the markings on the graph
  Unmark();

  int vertex, edge;
  
  // Initialize the edge traversal count
  edgeTraversalCount.resize(edges.size());
  for (edge = 0; edge < edgeTraversalCount.size(); edge++) edgeTraversalCount[edge] = 0;

  FindSourcesAndSinksFunctor<TVertex, TEdge> findSourceSink;
  findSourceSink.vertices = &vertices;
  findSourceSink.edges    = &edges;
  int source, sink;
  for (vertex = 0; vertex < vertices.size(); vertex++ ) {
    if (vertices[vertex].marked == GraphVertex::Marked)
      continue;
    
    // reset any previous result of sources and sinks
    findSourceSink.Clear();
    
    TraverseDFS(vertices, edges, vertex, findSourceSink);

    if (findSourceSink.sources.size() != findSourceSink.sinks.size()) {
      std::cout << "Warning: the graph does not have an even number of sources or sinks." << std::endl;
      std::cout << "The results are not well defined for this " << std::endl;
    }
  }
}


void IntervalGraph::IncrementOptimalPathCount(int source, 
																							std::vector<int> &sinks, 
																							std::vector<int> &edgeTraversalCount) {

  int sink;
  std::vector<int> shortestPathIndices;
  //  std::cout << "finding shortest paths from " << source << std::endl;
  SingleSourceMaximumPath(vertices, edges, source, shortestPathIndices);
  int curVertex;
  int edge;
  for (sink = 0; sink < sinks.size(); sink++) {
    curVertex = sinks[sink];
    int its = 0;
    while (curVertex != source and 
					 shortestPathIndices[curVertex] != -1) {
      assert(its < vertices.size());
      edge = vertices[curVertex].in[shortestPathIndices[curVertex]];
      edgeTraversalCount[edge]++;
      curVertex = edges[edge].src;
      its++;
    }
  }
}

void IntervalGraph::FindHighestScoringPathSourceToSink(int source, int sink, 
																											 std::vector<int> &edgeTraversalCount) {
  std::vector<int> shortestPathIndices;
  SingleSourceMaximumPath(vertices, edges, source, shortestPathIndices);

  TraceOptimalPath(vertices, edges, source, sink, shortestPathIndices, edgeTraversalCount);
}


void IntervalGraph::MarkBalancedEdges() {
  int edge;
  int balancedEdge;
  for (edge = 0; edge < edges.size(); edge++) {
    if (edges[edge].marked == GraphEdge::Marked) {
      balancedEdge = edges[edge].balancedEdge;
      if (balancedEdge >= 0) {
				edges[balancedEdge].marked = GraphEdge::Marked;
      }
    }
  }
}

int IntervalGraph::SearchForDirectedCycle(int sourceVertex, int curVertex, std::set<int> &visitedEdges,
																					int curPathLength, int maxCycleLength) {
  
  std::vector<int> sortedEdgeList;
  vertices[curVertex].GetSortedOutEdgeList(edges, sortedEdgeList);

  int outEdge, outEdgeIndex;
  int e;
  for (e =0 ; e < sortedEdgeList.size(); e++ ){
    outEdge = sortedEdgeList[e];
    if (visitedEdges.find(outEdge) != visitedEdges.end())
      continue;
    //		edges[outEdge].traversed = GraphEdge::Marked;
    if (curPathLength + edges[outEdge].length - vertices[edges[outEdge].src].vertexSize < maxCycleLength) {
      if (SearchForDirectedCycle(sourceVertex, edges[outEdge].dest, visitedEdges,
																 curPathLength + edges[outEdge].length - vertices[edges[outEdge].src].vertexSize, 
																 maxCycleLength)) {
				return 1;
      }
    }
  }
  return 0;
}

int IntervalGraph::SearchForUndirectedCycle2(int sourceVertex, int curVertex, std::set<int> &curPath, 
																						 int curPathLength, int maxCycleLength, int isUndirected,
																						 std::set<int> &visitedEdges, std::set<int> &visitedVertices) {

	// Make sure the path is not following a cycle to an internal
	// vertex (that will be dealt with later).
  if (visitedVertices.find(curVertex) != visitedVertices.end())
    return 0;


	// This is visiting a new vertex in the graph.  Record
	// that so we know the path.
  visitedVertices.insert(curVertex);


	// Visit in edges accor
  int inEdge, inEdgeIndex;
  std::vector<int> sortedEdgeList;
  vertices[curVertex].GetSortedInEdgeList(edges, sortedEdgeList);
  int e;
  for (e = 0; e < sortedEdgeList.size(); e++ ) {
    inEdge = sortedEdgeList[e];

    // If this edge has already been visited (perhaps in the other
		// direction), don't traverse it.
    if (visitedEdges.find(inEdge) != visitedEdges.end())
      continue;

		//
		// Check to see if this in-edge completes a small cycle
		// 
    if (sourceVertex == edges[inEdge].src and 
				curPathLength + edges[inEdge].length - vertices[curVertex].vertexSize < maxCycleLength ) {
      return 1;
    }
		
		// No small cycle is found.  Record this edge as visited, and continue searching.
    visitedEdges.insert(inEdge);

		// Traverse this edge in the opposite orientation, if it is possible to find
		// a short cycle after traversing this edge.
    if (curPathLength + ( edges[inEdge].length - vertices[edges[inEdge].dest].vertexSize) < maxCycleLength) {
      curPath.insert(inEdge);
      if (SearchForUndirectedCycle2(sourceVertex, edges[inEdge].src, curPath, 
																		curPathLength + edges[inEdge].length - vertices[edges[inEdge].dest].vertexSize,
																		maxCycleLength, 1, visitedEdges, visitedVertices)) {
				return 1;
      }
    }
  }


	// Visit in edges accor
  int outEdge, outEdgeIndex;
	sortedEdgeList.clear();
  vertices[curVertex].GetSortedOutEdgeList(edges, sortedEdgeList);

  for (e = 0; e < sortedEdgeList.size(); e++ ) {
    outEdge = sortedEdgeList[e];

    // If this edge has already been visited (perhaps in the other
		// direction), don't traverse it.
    if (visitedEdges.find(outEdge) != visitedEdges.end())
      continue;

		//
		// Check to see if this in-edge completes a small cycle
		// 
    if (sourceVertex == edges[outEdge].dest and 
				curPathLength + edges[outEdge].length - vertices[curVertex].vertexSize < maxCycleLength ) {
      return 1;
    }
		
		// No small cycle is found.  Record this edge as visited, and continue searching.
    visitedEdges.insert(outEdge);

		// Traverse this edge in the opposite orientation, if it is possible to find
		// a short cycle after traversing this edge.
    if (curPathLength + ( edges[outEdge].length - vertices[edges[outEdge].dest].vertexSize) < maxCycleLength) {
      curPath.insert(outEdge);
      if (SearchForUndirectedCycle2(sourceVertex, edges[outEdge].dest, curPath, 
																		curPathLength + edges[outEdge].length - vertices[edges[outEdge].src].vertexSize,
																		maxCycleLength, 1, visitedEdges, visitedVertices)) {
				return 1;
      }
    }
  }
  return 0;
}


int IntervalGraph::SearchForUndirectedCycle(int sourceVertex, int cycleEndVertex, int maxCycleLength) {
  //	std::cout << "searching fora cycle from " << sourceVertex << " to " << cycleEndVertex << std::endl;
  // Initialize the priority queue to hold the source vertex
  RBTree<ScoredVertex<int> > queue;

  ScoredVertex<int> closestVertex;

  // Use a set to count the vertices that are visisted.   Although it 
  // uses extra space and runs in n log n time, it lets us not unmark the entire tree
  // after looking for a cycle, which should only check out a very small subgraph.

  closestVertex.vertex = sourceVertex;
  closestVertex.score  = 0;
  // prepare references to scores
  std::map<int, HeapScoredVertex*> references;
  std::set<int> traversedEdges;
  references[sourceVertex] = queue.Insert(closestVertex);


  while(queue.size() > 0) {
    if (queue.Pop(closestVertex) == 0) {
      std::cout << "ERROR working with queue " << std::endl;
      exit(0);
    }
		
    //    std::cout << "got vertex " << scoredVertex.vertex << std::endl;
    // First difference from normal Dijkstra: if there are any in edges
    // that are not already part of the dag.

    // Try and relax any of the edges going out of the current
    // vertex.
    
    int inEdgeIndex, inEdge;
    std::vector<int> sortedEdgeList;
    ScoredVertex<int> srcVertex;
    vertices[closestVertex.vertex].GetSortedInEdgeList(edges, sortedEdgeList);
    //		std::cout << "searching in edge list of length: " << sortedEdgeList.size() << std::endl;
    int in;
    for (in = 0; in < sortedEdgeList.size(); in++ ) {
      inEdge = sortedEdgeList[in];
      if (traversedEdges.find(inEdge) != traversedEdges.end())
				continue;
      traversedEdges.insert(inEdge);
      if (edges[inEdge].length + closestVertex.score < maxCycleLength) {
				if (edges[inEdge].src == cycleEndVertex) {
					/*
						std::cout << "found a cycle ending at edge " << inEdge << " " << edges[inEdge].src 
						<< " " << edges[inEdge].dest << " of length: " 
						<< edges[inEdge].length + closestVertex.score << std::endl;
					*/
					// CYCLE FOUND!
					return 1;
				}
				else {
					srcVertex.vertex = edges[inEdge].src;

					// It is necessary to update the distance in the queue if
					// the vertex doesn't exist in the queue, or it can be reached 
					// from 'inEdge' with less distance.
					if (references.find(srcVertex.vertex) == references.end() or 
							edges[inEdge].length + closestVertex.score < references[srcVertex.vertex]->data.score) {
						
						// it's possible this edge forms a cycle. update it in the queue
						if (references.find(srcVertex.vertex) != references.end()) {
							queue.Delete(references[srcVertex.vertex]);
						}
						
						srcVertex.score = edges[inEdge].length + closestVertex.score;
						/*
							std::cout << "vertex: " << srcVertex.vertex << " is reachable from " 
							<< srcVertex.score << std::endl;
						*/
						references[srcVertex.vertex] = queue.Insert(srcVertex);
						//						std::cout <<" queue size: " << queue.size() << std::endl;
					}
				}
      }
    }

    // process out edges

    int outEdgeIndex, outEdge;
    ScoredVertex<int> destVertex;
    sortedEdgeList.clear();
    vertices[closestVertex.vertex].GetSortedOutEdgeList(edges, sortedEdgeList);
    //		std::cout << "searching out edge list of length: " << sortedEdgeList.size() << std::endl;
    int out;
    for (out = 0; out < sortedEdgeList.size(); out++ ) {
      outEdge = sortedEdgeList[out];
      if (traversedEdges.find(outEdge) != traversedEdges.end())
				continue;
      traversedEdges.insert(outEdge);

      if (edges[outEdge].length + closestVertex.score < maxCycleLength) {
				if (edges[outEdge].dest == cycleEndVertex) {
					//					std::cout << "found a cycle of length: " << edges[outEdge].length + closestVertex.score << std::endl;
					// CYCLE FOUND!
					return 0;
				}
				else {
					destVertex.vertex = edges[outEdge].dest;

					// It is necessary to update the distance in the queue if
					// the vertex doesn't exist in the queue, or it can be reached 
					// from 'outEdge' with less distance.
					if (references.find(destVertex.vertex) == references.end() or 
							edges[outEdge].length + closestVertex.score < references[destVertex.vertex]->data.score) {
						
						// it's possible this edge forms a cycle. update it in the queue
						if (references.find(destVertex.vertex) != references.end()) {
							queue.Delete(references[destVertex.vertex]);
						}
						
						destVertex.score = edges[outEdge].length + closestVertex.score;
						/*						std::cout << "vertex: " << destVertex.vertex << " is reachable from " 
													<< destVertex.score << std::endl;
						*/
						references[destVertex.vertex] = queue.Insert(destVertex);
						//						std::cout <<" queue size: " << queue.size() << std::endl;
					}
				}
      }
    }
    // No cycle has been found from 'curVertex'.
  }
  return 0;
}

void IntervalGraph::RemoveWhirls(int whirlLength) {
	std::vector<int> edgesToRemove, verticesToRemove;
	int edge;
	for (edge = 0; edge < edges.size(); edge++) {
		if (edges[edge].src == edges[edge].dest and 
				edges[edge].length < whirlLength) {
			edgesToRemove.push_back(edge);
		}
	}
	std::cout << "Found " << edgesToRemove.size() << " whirls." << std::endl;
  RemoveEdgeAndMarkIntervalsForRemoval(edgesToRemove, verticesToRemove);

	Prune(verticesToRemove, edgesToRemove);
}

int IntervalGraph::RemoveBulgingEdges(int bulgeLength, int iter) {
  int edge;
  std::vector<int> edgesToRemove, orphanedVertices;
  std::set<int> edgesToRemoveSet;
  //	Untraverse();
  std::set<int> curPath, visitedEdges, visitedVertices;
  Untraverse();
  int numNotMarked = 0;

  for (edge = 0; edge < edges.size(); edge++) {
    if (edges[edge].marked == GraphEdge::NotMarked) { // only check non DMST edgs
      curPath.clear();
      visitedEdges.clear();
      visitedVertices.clear();
      ++numNotMarked;
      //			curPath.insert(edge);
      //			std::cout << "checking edge: " << edge << " " << edges[edge].index << " for cycleness " << std::endl;
      edges[edge].traversed = GraphEdge::Marked;
      visitedEdges.insert(edge);
      visitedVertices.insert(edges[edge].src);
      if (SearchForUndirectedCycle2(edges[edge].src, edges[edge].dest, curPath, 
																		edges[edge].length, bulgeLength, 0, visitedEdges, visitedVertices)) {
				//			if (SearchForUndirectedCycle(edges[edge].src, edges[edge].dest, bulgeLength)) {
				//	std::cout << "edge: " << edge << " creates a cycle, not keeping it " << std::endl;
				edgesToRemoveSet.insert(edge);
      }

      edges[edge].traversed = GraphEdge::NotMarked;
    }
  }
  std::cout << "bulge removal found " << edgesToRemoveSet.size() << " edges in short bulges of " 
						<< numNotMarked << " edges in bulges of " << edges.size() << " total edges." << std::endl;
  for (edge = 0; edge < edges.size(); edge++ ) {
    if (edgesToRemoveSet.find(edge) != edgesToRemoveSet.end()) {
      edgesToRemoveSet.insert(edges[edge].balancedEdge);
    }
  }
  // Turn the set into a vector
  edgesToRemove.insert(edgesToRemove.begin(), edgesToRemoveSet.begin(), edgesToRemoveSet.end());
  std::sort(edgesToRemove.begin(), edgesToRemove.end());
	
  Unflag();
  for (edge = 0; edge < edgesToRemove.size(); edge++) {
    edges[edgesToRemove[edge]].flagged = GraphEdge::Marked;
		/*    std::cout << "removing " << edgesToRemove[edge] << " "
							<< edges[edgesToRemove[edge]].index << " "
							<< edges[edgesToRemove[edge]].length << std::endl;*/
  }
	/*  std::stringstream dotfilestrm;
  dotfilestrm << "beforebulgeremoving." << iter << ".dot";
	
  std::string removed = dotfilestrm.str();
  GVZPrintBGraph(vertices, edges, removed);
	*/
	
  RemoveEdgeAndMarkIntervalsForRemoval(edgesToRemove, orphanedVertices);
	/*
  dotfilestrm.str("");
  dotfilestrm << "beforepruning." << iter << ".dot";
  std::string before(dotfilestrm.str());
  GVZPrintBGraph(vertices, edges, before);
	*/
  Prune(orphanedVertices, edgesToRemove);

	/*
  dotfilestrm.str("");
  dotfilestrm << "afterpruning." << iter << ".dot";
  std::string after(dotfilestrm.str());
  GVZPrintBGraph(vertices, edges, after);
	*/

  int numRerouted = RouteRemovedIntervals(40);

  RemoveMarkedIntervals();
  SortAllEdgeIntervalsByReadPos();
  UpdateAllPathIndices();

  DiscardGappedPaths();
  CheckGraphStructureBalance();
  CheckAllPathsBalance(1);

  int numCondensed = CondenseSimplePaths();
  std::cout << "After bulge removal, condensed " << numCondensed <<" edges " << std::endl;

  /*
    std::string after = "aftercondensing.dot";
    GVZPrintBGraph(vertices, edges, after);
  */
  CheckAllPathsBalance(1);
  /* Do some post-processing of the graph to remove some untidy edges.*/
  Erode(bulgeLength/2);
  RemoveMarkedIntervals();
  return edgesToRemove.size();
}

void IntervalGraph::SetMultiplicities() {
  int e;
  for (e = 0; e < edges.size(); e++) {
    edges[e].multiplicity = edges[e].intervals->size();
  }
}

void IntervalGraph::RemoveBulges(int bulgeLength) {
  int numRemovedEdges;
  int iter = 0;
  std::stringstream pathOutStrm;
	RemoveEmptyEdges();
  do {
    Unmark();
    SetMultiplicities();
    CalcDMST();
		//    std::string dmst = "dmst.dot";
		//    GVZPrintBGraph(vertices ,edges, dmst);
    MarkBalancedEdges();
    numRemovedEdges = RemoveBulgingEdges(bulgeLength, iter);
    pathOutStrm.str("");
    pathOutStrm << "removed."<<iter<< ".txt";
    CheckAllPathsBalance(1);
    CheckAllPathsContinuity(1);
    ++iter;
    std::cout << "Remove bulges iter: " << iter << " " << numRemovedEdges << " bulging edges " << std::endl;
  } while (numRemovedEdges != 0);
}


int IntervalGraph::RemoveTruncatedPathIntervals() {
  // Often paths will be truncated at their ends.
  // This function erases the truncated parts, and
  // udpates the indices in edges to reference
  // back to the paths accordingly (so if the first
  // two intervals of a path are deleted, the 
  // eges that contain later parts of the path must
  // have the pathPos values for the interval decremented
  // by 2.
  int p, pre, suf, pos;
  for (p = 0; p < paths.size(); p++ ) {
    if (pathLengths[p] > 0) {
      pre = 0;
      while (pre < pathLengths[p] and
						 paths[p][pre].edge == -1)
				pre++;
      // The entire path is removed, nothing to do
      if (pre == pathLengths[p]) {
				delete[] paths[p];
				paths[p] = NULL;
				pathLengths[p] = 0;
				continue;
      }
			
      suf = pathLengths[p] - 1;
      while (suf >= pre and paths[p][suf].edge == -1)
				suf--;
			
      if (suf - pre + 1 == pathLengths[p])
				continue;

      if (suf < pre) {
				delete[] paths[p];
				paths[p] = NULL;
				pathLengths[p] = 0;
      }
      // replace paths with the truncated path
      PathInterval *newPath = new PathInterval[suf-pre+1];
      for (pos = pre; pos <= suf; pos++) {
				newPath[pos - pre] = paths[p][pos];
      }
      delete[] paths[p];
      paths[p] = newPath;
			
      pathLengths[p] = suf - pre + 1;
      // now update the position in each edge
			
      for (pos = 0; pos < pathLengths[p]; pos++) {
				if (paths[p][pos].edge != -1) {
					(*edges[paths[p][pos].edge].intervals)[paths[p][pos].index].pathPos = pos;
				}
      }
    }			
  }
}

int IntervalGraph::SearchForCycle(int sourceVertex, int prevVertex, int curVertex, 
																	int curPathLength, int maxPathLength, std::string padding) {
  
  // End case, a cycle is found
  if (curVertex == sourceVertex) {
    std::cout << "search2 found cycle " << std::endl;
    return 1;
  }

  // For now explore all paths in the graph.  Of course this
  // will take a while when allowing large paths
  int outEdge, outEdgeIndex, inEdge, inEdgeIndex;
  for (outEdgeIndex = vertices[curVertex].FirstOut(); 
       outEdgeIndex < vertices[curVertex].EndOut();
       outEdgeIndex = vertices[curVertex].NextOut(outEdgeIndex)) {
    outEdge = vertices[curVertex].out[outEdgeIndex];
    if (edges[outEdge].dest != prevVertex and
				edges[outEdge].length + curPathLength - vertexSize < maxPathLength) {
      /*
				std::cout << padding << "searching " << curVertex << " - " << outEdge << " > " << edges[outEdge].dest
				<< " " << edges[outEdge].length << " " << curPathLength << std::endl;
      */
      if (SearchForCycle(sourceVertex, curVertex, edges[outEdge].dest, 
												 edges[outEdge].length + curPathLength - vertexSize, maxPathLength, padding + " "))
				return 1;
    }
  }
  for (inEdgeIndex = vertices[curVertex].FirstIn(); 
       inEdgeIndex < vertices[curVertex].EndIn();
       inEdgeIndex = vertices[curVertex].NextIn(inEdgeIndex)) {
    inEdge = vertices[curVertex].in[inEdgeIndex];
    if (edges[inEdge].src != prevVertex and
				edges[inEdge].length + curPathLength - vertexSize < maxPathLength) {
      /*
				std::cout << padding << "searching " << curVertex << " < " << inEdge << " - " << edges[inEdge].src
				<< " " << edges[inEdge].length << " " << curPathLength << std::endl;
      */
      if (SearchForCycle(sourceVertex, curVertex, edges[inEdge].src, 
												 edges[inEdge].length + curPathLength - vertexSize, maxPathLength, padding + " ")) {
				return 1;
      }
    }
  }

  // At the end of the function, no cycle found
  return 0;
}



void IntervalGraph::ProtectEdges(std::string &protectedEdgeFileName,
																 int edgeTupleLength) {
	//	std::cout << "Function ProtectEdges is deprecated." << std::endl;
  ReadPositions protPositions;
  HashValueFunctor calcHashValue;
  calcHashValue.hashLength = 10;
  HashedSpectrum hashTable(calcHashValue);

  SimpleSequenceList seqList;
  ReadSimpleSequences(protectedEdgeFileName, seqList);

  CountedReadPos::hashLength = edgeTupleLength;
  CountedReadPos::sequences  = &seqList;
  calcHashValue.sequences    = &seqList;
	
	hashTable.hashFunction = calcHashValue;
	hashTable.StoreSpectrum(seqList);
	//	StorSpectrum(seqList, hashTable, calcHashValue);
	//	HashToReadPositionList(hashTable, seqList, edgeTupleLength, protPositions);
	hashTable.HashToReadPositionList(seqList, protPositions);
	CompareTuples<SimpleSequenceList> comp;
  comp.sequencesPtr = &seqList;
  comp.length = edgeTupleLength;
	std::sort(protPositions.begin(), protPositions.end(), comp);

	std::cout << "there are: " << protPositions.size() << " protected positions." << std::endl;
  ProtectEdges(protPositions, seqList, edgeTupleLength);
}


void IntervalGraph::ProtectEdges(ReadPositions &protectedPositions, 
																 SimpleSequenceList &protectedEdges, 
																 int edgeTupleLength) {
  int e;
  int protIndex;
  int totalProtected = 0;
  int bale;
  int p;
  int guarded;
  for (e = 0; e < edges.size(); e++ ) {
    guarded = 0;
    for (p = 0; !guarded and p < edges[e].length - edgeTupleLength + 1; p++) {
      protIndex = LocateTuple(protectedEdges, protectedPositions, 
															edgeTupleLength, (char*) &(edges[e].seq.seq[p]));
      if (protIndex >= 0) {
				guarded = 1;
      }
    }

    if (guarded) {
      if (edges[e].guarded != GraphEdge::Marked) {
				edges[e].guarded = GraphEdge::Marked;
				//				std::cout << "protecting edge: " << e << std::endl;
				edges[e].multiplicity += 100;
				++totalProtected;
      }
      bale = edges[e].balancedEdge;
      if (edges[bale].guarded != GraphEdge::Marked) {
				//				std::cout << "protecting balance " << bale << std::endl;
				++totalProtected;
				edges[bale].multiplicity += 100;
      }
    }
  }
  std::cout << "protected: " << totalProtected << " / " << edges.size() << std::endl;
}

int IntervalGraph::CountReadsContainedInEdge(int edge){ 
  int i;
  int read, pos;
  int numContainedReads = 0;
  for (i = 0; i < edges[edge].intervals->size(); i++) {
    read = (*edges[edge].intervals)[i].read;
    pos  = (*edges[edge].intervals)[i].readPos;
		
    if (pathLengths[read] == 1) {
      numContainedReads++;
    }
  }
  return numContainedReads;
}

int IntervalGraph::CountReadsExtendingIntoEdge(int edge, int limit) {
  int i;
  int read, pos;
  int numExtendInto = 0;
  for (i = 0; i < edges[edge].intervals->size(); i++) {
    read = (*edges[edge].intervals)[i].read;
    pos  = (*edges[edge].intervals)[i].pathPos;
    if (pathLengths[read] == 1)
      continue;
    if (pos == 0 and 
				edges[edge].length - (*edges[edge].intervals)[i].edgePos > limit) {
      numExtendInto++;
    }
    else if (pos == pathLengths[read]-1 and
						 (*edges[edge].intervals)[i].length > limit) {
      numExtendInto++;
    }
  }
  return numExtendInto;
}


void IntervalGraph::RemoveLowPathEdges(int minPaths, int minExtend) {
  int e;
  std::vector<int> verticesToRemove, edgesToRemove;
  int npaths;
  for (e = 0; e < edges.size(); e++) { 
    npaths = CountReadsContainedInEdge(e) +
      CountReadsPassingThroughEdge(e) +
      CountReadsExtendingIntoEdge(e, minExtend);
    if (npaths < minPaths) {
      RemoveEdgeAndMarkPathsForRemoval(e, verticesToRemove);
      edgesToRemove.push_back(e);
    }
  }
  RemoveMarkedIntervals();
  Prune(verticesToRemove, edgesToRemove);
	RemoveEmptyEdges();
}

int IntervalGraph::CountReadsPassingThroughEdge(int edge) {
  int i;
  int read, pos;
  int numPassingThrough = 0;
  for (i = 0; i < edges[edge].intervals->size(); i++) {
    read = (*edges[edge].intervals)[i].read;
    pos  = (*edges[edge].intervals)[i].pathPos;

    if (pos > 0 and pos < pathLengths[read] - 1) {
      numPassingThrough++;
    }
  }
  return numPassingThrough;
}

void IntervalGraph::PathToThread(int p, ThreadPath &path) {
	path.clear();
	int i, pathEdge, pathInterval;
	int destVertex, destVertexLength, intvLength, intvPos;
	int readLength;
	for (i = 0; i < pathLengths[p] - 1; i++) {
		// Look up the edge, interval for this path interval
		pathEdge     = paths[p][i].edge;
		pathInterval = paths[p][i].index;
				
		// Find the length along this path interval
		destVertex       = edges[pathEdge].dest;
		destVertexLength = vertices[destVertex].vertexSize;
		intvLength       = (*edges[pathEdge].intervals)[pathInterval].length -
			destVertexLength;
		intvPos = (*edges[pathEdge].intervals)[pathInterval].edgePos;
		path.push_back(ThreadPathInterval(pathEdge, intvLength, intvPos));
		readLength += intvLength;
		//				std::cout << " " << intvLength;
	}
	// The last interval includes the entire vertex length
	pathEdge     = paths[p][i].edge;
	pathInterval = paths[p][i].index;
	intvLength   = (*edges[pathEdge].intervals)[pathInterval].length;
	intvPos      = (*edges[pathEdge].intervals)[pathInterval].edgePos;
	//			std::cout << " " << intvLength << std::endl;
	readLength += intvLength;
	//			std::cout << pathLengths[p] << " " << readLength << " ";
	path.push_back(ThreadPathInterval(pathEdge, intvLength, intvPos));

}
