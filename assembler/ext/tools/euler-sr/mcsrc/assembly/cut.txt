		//		if (detachIter > 0) {
		if (0) {
			// When not on the first iteration, attempt to resolve mate-paths
			// by condensing ambiguous repeats.
			EdgePairMap::iterator epIt, epEnd;
			std::vector<int> edgeOnPathCount, pathVect;
			edgeOnPathCount.resize(edges.size());
			// Initialize the counts to 0.
			std::fill(edgeOnPathCount.begin(), edgeOnPathCount.end(), 0);

			std::vector<int> edgeTraversalCount;
			edgeTraversalCount.resize(edges.size());
			// Mark all edges that are on part of a putative mate-path.
			for (epIt = pairedEdgeMap.begin(),
						 epEnd = pairedEdgeMap.end(); epIt != epEnd; ++epIt) {
				if ((*epIt).second.numPaths > 1) {
					pathVect.resize(rules[(*epIt).first.mateType].cloneLength + 
													rules[(*epIt).first.mateType].cloneVar);
					std::fill(pathVect.begin(), pathVect.end(), -1);
					int numPaths = 0;
					int totalLength = 0;
					int totalEdges = 0;
					MarkEdgesOnValidMatePaths(graph, (*epIt).first.edge1, (*epIt).second.meanEdge1End,
																		(*epIt).first.edge2, (*epIt).second.meanEdge2Start,
																		0, 
																		rules[(*epIt).first.mateType].cloneLength -
																		rules[(*epIt).first.mateType].cloneVar,
																		rules[(*epIt).first.mateType].cloneLength +
																		rules[(*epIt).first.mateType].cloneVar,
																		30, pathVect, 0, edgeOnPathCount, 
																		numPaths, totalLength, totalEdges, edgeTraversalCount);
					int averageLength = 0;
					int averageNumEdges = 0;
					if (numPaths > 0) {
						averageLength = (int) (totalLength * 1.0/numPaths);
						averageNumEdges = totalEdges / numPaths;
					}
					(*epIt).second.averageNumEdges = averageNumEdges;
					(*epIt).second.numPaths = numPaths;
					
					std::cout << (*epIt).first.edge1 << " " << (*epIt).first.edge2 << " " 
										<< (*epIt).second.numPaths << " " << numPaths << " " 
										<< averageLength << " "
										<< (*epIt).second.averageNumEdges << std::endl;
					/*
						int v;
						for (v =0 ; v < pathVect.size() and pathVect[v] != -1; v++ ){
						std::cout << pathVect[v] << " ";
					}
					std::cout << std::endl;
					*/
				}
			}
			
			std::vector<std::pair<int, MatePairMap*> > orderedEdgePairIndex;
			orderedEdgePairIndex.resize(pairedEdgeMap.size());
			int i = 0;
			for (epIt = pairedEdgeMap.begin(); epIt != epEnd; ++epIt) {
				orderedEdgePairIndex[i].first = (*epIt).second.averageNumEdges;
				orderedEdgePairIndex[i].second = &(*epIt).second;
				i++;
			}
			std::sort(orderedEdgePairIndex.begin(),
								orderedEdgePairIndex.end());
			for (i = 0; i < orderedEdgePairIndex.size(); i++) {
				std::cout << i << " " << orderedEdgePairIndex[i].second->edge1 << " " 
									<< orderedEdgePairIndex[i].second->edge2 << " " 
									<< orderedEdgePairIndex[i].second->averageNumEdges << std::endl;
			}
		}


int FindMaximallySupportedPath(IntervalGraph &g, int srcEdge, int destEdge,
														 MateEdgeMap &pairedEdges,
														 std::list<int> &curSupportedPath, int curSupportedPathScore,
														 std::list<int> &maxSupportedPath, int maxSupportedPathScore) {
	// Goal: find a path from src edge to dest edge
	// with a maximal number of paired edges.

	// Base case, the destination edge is reached.
	if (srcEdge == destEdge) {
		if (curSupportedPathScore > maxSupportedPathScore) {
			maxSupportedPath = curSupportedPath;
			maxSupportedPathScore = curSupportedPathScore;
			return curSupportedPathScore;
		}
		return 0;
	}

	// Next case, search for the destination edge.
	int outEdge, outEdgeIndex;
	int destVertex = g.edges[srcEdge].dest;
	int nextPathEdge;
	for (outEdgeIndex = g.vertices[destVertex].FirstOut();
			 outEdgeIndex != g.vertices[destVertex].EndOut();
			 outEdgeIndex = g.vertices[destVertex].NextOut(outEdgeIndex)) {
		outEdge = g.vertices[destVertex].out[outEdgeIndex];
		int numAdvanced;
		if ((numAdvanced = 
				 AdvancePathAlongPairedEdges(g, outEdge, pairedEdges, destEdge, curSupportedPath))) {
			
		}
	}
}



		std::cout << "checking :"  << sourceEdges.size() << " source edges." << std::endl;
		for (so = 0; so < sourceEdges.size(); so++) {

			// Check for mates that reach the source
			// edge from other parts of the graph.

			sourceEdge = sourceEdges[so];
			ReadIntervalList *intervals;
			intervals = graph.edges[sourceEdge].intervals;
			int noMate = 0;
			for (intv = 0; intv < intervals->size(); intv++) {
				pathIndex = (*intervals)[intv].read;
				pathPos   = (*intervals)[intv].pathPos;

				// only consider mates where this is the recipient
				if (pathIndex % 2 != 1)
					// only process reads in the forward direction since the 
					// reverse complement is handled by the mate.
					continue;

				readIndex = pathIndex / 2;

				mateIndex = mateList[readIndex].mateIndex * 2;
				mateType  = mateList[readIndex].mateType;
				int lastEdge, lastIntv;
				int mateLastEdge, mateLastIntv;
				int firstEdge, firstIntv;
				if (GetFirstEdgeIndex(graph.paths, graph.pathLengths, pathIndex, firstEdge, firstIntv) == 0) {
					// The path for this read has been deleted, or something bad has happened.
					// I'm not sure if this should ever happen.
					assert(0);
				}
				// there should be no edges preceeding source in the graph.
				assert(firstEdge == sourceEdge);
				if (mateIndex >= 0 ) {
					if (GetLastEdgeIndex(graph.paths, 
															 graph.pathLengths, mateIndex, mateLastEdge, mateLastIntv)) {
						if (firstEdge != mateLastEdge) {
							int distToEnd   = graph.edges[mateLastEdge].length - 
								(*graph.edges[mateLastEdge].intervals)[mateLastIntv].edgePos;
							int distToStart = (*intervals)[firstIntv].edgePos;
								
							/*							if (distToEnd + distToStart < 
															rules[mateType].cloneLength + rules[mateType].cloneVar) {*/
							std::cout << sourceEdge << " " << mateLastEdge << " " << distToEnd + distToStart 
												<< " " << readIndex << std::endl;
							// Register this link.
							if (sourceToSinkMateCount[sourceEdge].find(mateLastEdge) == 
									sourceToSinkMateCount[sourceEdge].end()) {
								sourceToSinkMateCount[sourceEdge][mateLastEdge].count = 1;
							}
							else {
								sourceToSinkMateCount[sourceEdge][mateLastEdge].count++;
							}
						}
						//						}
					}
				}
				else {
					++noMate;
				}
			}
			std::cout << "of: " << (*intervals).size() << " " << noMate << " had no mates." << std::endl;
		}
	}

