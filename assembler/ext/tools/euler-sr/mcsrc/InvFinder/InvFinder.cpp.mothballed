/***************************************************************************
 * Title:          InvFinder.cpp 
 * Author:         Mark Chaisson
 * Created:        2007
 * Last modified:  2007
 *
 * Copyright (c) 2007-2008 The Regents of the University of California
 * All Rights Reserved
 * See file LICENSE for details.
 ***************************************************************************/
#include <iostream>
#include <ostream>
#include <stdio.h>

#include "DNASequence.h"
#include "SeqReader.h"
#include "align/alignutils.h"
#include "StripGen.h"
#include "TupleLib.h"
#include "SeqUtils.h"

#include "SimpleStats.h"

float AlignAroundPosition(DNASequence &refSeq, int refStartPos, int refEndPos,
			  DNASequence &qrySeq, int qryStartPos, int qryEndPos,
			  int *&locations, // map of refseq to qryseq
			  int &length, // length of optimal local alignment
			  int &refStartAlignPos, int &qryStartAlignPos,
			  FloatMatrix &scoreMat);

float AlignSubsequences(DNASequence &refSeq, int refPos, int refLength,
			DNASequence &qrySeq, int qryPos, int qryLength, 
			int *&locations, // map of refseq to qryseq
			int &length, // length of optimal local alignment
			int &refAlignStart, // start of local alignment in ref seq
			int &qryAlignStart, // start of local alignment in qry seq
			FloatMatrix &scoreMat,
			int  extendAlignment);

void InitEnv(int argc, char* argv[], 
	     std::string &refSeqName, 
	     std::string &qrySeqName,
	     std::string &scaffoldName,
	     std::string &scoreMatFile,
	     std::string &scoreMatString,
	     std::string &alignOutput,
	     std::string &outputFile,
	     float &tailEndPct,
	     int &window, int &step,
	     int &extendAlignment);

int NestedInversion(int pos, int *enumerations, int *startQryLocations, int *endQryLocations);

void PrintUsage();
void RotateAlignment(int *alignment, int alignLength, int alignSpan) {
  int i;
  for (i = 0; i < alignLength ; i++) {
    if (alignment[i] != -1)
      alignment[i] = alignSpan - alignment[i] - 1;
  }
}

int main(int argc, char* argv[]) {

  std::string qrySeqName, refSeqName, scaffoldName;
  std::string scoreMatFile, scoreMatString;
  std::string alignOutputName, outputName;
  DNASequence refSeq;
  DNASequence qrySeq;
  int  *enumerations;
  int *startRefLocations, *endRefLocations;
  int *startQryLocations, *endQryLocations;
  int *stripSize, *stripsMerged;
  int numScaffolds;
  int length, step;
  FloatMatrix scoreMat;
  int i;
  float topPct;
  int extendAlignment;
  length = 1000;
  step   = 500;
  topPct = 0.05;
  scoreMatFile = "";
  scoreMatString = "";
  alignOutputName = "";
  outputName = "";
  extendAlignment = 0;
  InitEnv(argc, argv, 
	  refSeqName, qrySeqName, scaffoldName, 
	  scoreMatFile, scoreMatString, 
	  alignOutputName, outputName, 
	  topPct,
	  length, step,
	  extendAlignment);
  std::ofstream output;
  std::ostream *outputPtr;
  if (outputName == "")
    outputPtr = &std::cout;
  else {
    output.open(outputName.c_str());
    if (!output.good()) {
      std::cout << "Could not open output file " << outputName << std::endl;
      exit(0);
    }
    outputPtr = &output;
  }

  std::ofstream alignOutput;
  std::ostream *alignOutputPtr;
  if (alignOutputName == "")
    alignOutputPtr= NULL;
  else {
    alignOutput.open(alignOutputName.c_str());
    if (!alignOutput.good()) {
      std::cout << "Could not open alignment file " << alignOutputName << std::endl;
      exit(0);
    }
    alignOutputPtr = &alignOutput;
  }

  if (scoreMatFile != "") {
    ReadScoreMatFile(scoreMatFile, scoreMat);
  }
  // Get input.
  SeqReader::MaskRepeats();
  SeqReader::GetSeq(refSeqName, refSeq);
  SeqReader::GetSeq(qrySeqName, qrySeq);
  
  // Store the scaffold as an array of locations;
  ReadStrips(scaffoldName,
	     enumerations, startRefLocations, endRefLocations,
	     startQryLocations, endQryLocations, stripSize, 
	     stripsMerged, numScaffolds);
  
  // For each region in the scaffold (stretch of sequence
  // spanned by two consecutively enumerated markers), look 
  // for inversions.
  int s;
  int qryPos, refPos;
  int refLength, qryLength;
  float alignScore;
  int *alignment, *tmpEnum, alignLength;
  int refAlignStart, qryAlignStart;
  int endRefPos, endQryPos;
  std::vector<int*> alignments;
  std::vector<float> scores;
  std::vector<int>  refLocations, qryLocations, seqLengths, alignLengths;
  DNASequence refSubSeq, qrySubSeq;
  int alignsdone;
  alignsdone = 0;
  int ni;
  for ( s = 0; s < numScaffolds-1 ; s++) {
    if (enumerations[s] + 1 == enumerations[s+1]) {// ||   // either enumerations are adjacent
      // or there is an inversion surrounded
      // (s < numScaffolds-2) && NestedInversion(s, enumerations, startQryLocations, endQryLocations)) {

      if (enumerations[s]+1 != enumerations[s+1]) { 
	//s < numScaffolds-2 && NestedInversion(s, enumerations,  startQryLocations, endQryLocations)){
	refPos = startRefLocations[s];
	qryPos = startQryLocations[s];
	endRefPos = startRefLocations[s+2];
	endQryPos = startQryLocations[s+2];
	std::cout << "aligning nested inversion " << endRefLocations[s] << " " << startRefLocations[s+2] << " "
		  << enumerations[s] << " " << enumerations[s+1] << " " << enumerations[s+2] << std::endl;
	
	ni  = 1;
      }
      else {
	if (Sign(enumerations[s]) == 1 && Sign(enumerations[s]) == 1) {
	  refPos = startRefLocations[s];
	  qryPos = startQryLocations[s];
	  endRefPos = startRefLocations[s+1];
	  endQryPos = startQryLocations[s+1];
	}
	if (Sign(enumerations[s]) == -1 && Sign(enumerations[s]) == -1) {
	  refPos = startRefLocations[s];
	  qryPos = startQryLocations[s+1];
	  endRefPos = startRefLocations[s+1];
	  endQryPos = startQryLocations[s];
	  std::cout << "aligning between rev dir markers " << refPos << " " << endRefPos 
		    << " " << qryPos << " " << endQryPos << " "  << endRefPos - refPos << std::endl;
	}

	ni = 0;
      }
      int continueAligning = 1;
      while (refPos < endRefPos && qryPos < endQryPos) {
	alignsdone++;
	refLength = std::min(length, endRefPos - refPos - 1);
	qryLength = std::min(length, endQryPos - qryPos - 1);
	alignScore = AlignSubsequences(refSeq, refPos, refLength,
				       qrySeq, qryPos, qryLength,
				       alignment, alignLength, 
				       refAlignStart, qryAlignStart,
				       scoreMat, extendAlignment); 
	if (ni) {
	  std::cout << "ni align score following " <<std::endl;
	}
	if (alignment != NULL) {
	  std::cout << alignScore << "\t" << refPos + refAlignStart << "\t"
		    << alignment[0] - alignment[alignLength- 1] << std::endl;
	  alignments.push_back(alignment);
	  alignLengths.push_back(alignLength);
	  seqLengths.push_back(alignment[0] - alignment[alignLength-1] + 1);
	  scores.push_back(alignScore);
	  refLocations.push_back(refPos + refAlignStart);
	  qryLocations.push_back(qryPos + qryAlignStart);
	}
	else
	  std::cout << 0 << "\t" << refPos + refAlignStart << "\t"
		    << 0 << std::endl;
	
	refPos += step;
	qryPos += step;
      }
    }
  else if (Sign(enumerations[s]) == -1) {
      DNASequence refSubseq, qrySubseq;
      int rsp, rep, qsp, qep;
      int seedLength = endRefLocations[s] - startRefLocations[s];
      rsp = max(0, startRefLocations[s] - length);
      rep = min(refSeq.length, endRefLocations[s] + length);
      refSubseq.seq = &refSeq.seq[rsp];
      refSubseq.length = rep - rsp + 1;
      
      qsp = max(0, endQryLocations[s] - length);
      qep = min(qrySeq.length, startQryLocations[s] + length);
      qrySubseq.seq = &qrySeq.seq[qsp];
      qrySubseq.length = qep - qsp + 1;
      int *alignLocs, alignLength;
      int refAlignStart, qryAlignStart;
      AlignAroundPosition(refSubseq, 
			  startRefLocations[s] - rsp, 
			  startRefLocations[s] - rsp + seedLength + 1,
			  qrySubseq, 
			  endQryLocations[s] - qsp, 
			  endQryLocations[s] - rsp + seedLength + 1,
			  alignLocs, // map of refseq to qryseq
			  alignLength, // length of optimal local alignment
			  refAlignStart, qryAlignStart,
			  scoreMat);
    }
  }

  std::vector<int> topPctIdx;
  GetTail(scores, topPctIdx, topPct);
  int a, c, t, g;
  int j, index;
  for (i = 0; i < topPctIdx.size(); i++) {
    index = topPctIdx[i];
    refSubSeq.seq = &(refSeq.seq[refLocations[index]]);
    refSubSeq.length = alignLengths[index] ;
    qrySubSeq.seq = &(qrySeq.seq[qryLocations[index]]);
    qrySubSeq.length = seqLengths[index];
    if (alignOutputPtr != NULL) {
      T_Alignment tmpAlignment;
      tmpAlignment.enumerations = new int[alignLengths[index]];
      for (j = 0; j < alignLengths[index]; j++) tmpAlignment.enumerations[j] = j - alignLengths[index];
      tmpAlignment.locations = alignments[index];
      tmpAlignment.length    = alignLengths[index];
      PrintAlignment(alignOutputPtr, refSubSeq, qrySubSeq, tmpAlignment);
      delete tmpAlignment.enumerations;
    }

    // Print informative information about the alignments
    *outputPtr << alignLengths[index] << "\t" << scores[index] << "\t" 
	       << refLocations[index] << "\t" << qryLocations[index] << " ";
    CountACTG(refSubSeq, a, c, t, g);
    *outputPtr << a *1.0 / refSubSeq.length << " ";
    *outputPtr << c *1.0 / refSubSeq.length << " ";
    *outputPtr << t *1.0 / refSubSeq.length << " ";
    *outputPtr << g *1.0 / refSubSeq.length << " ";

    CountACTG(qrySubSeq, a, c, t, g);
    *outputPtr << a *1.0 / qrySubSeq.length << " ";
    *outputPtr << c *1.0 / qrySubSeq.length << " ";
    *outputPtr << t *1.0 / qrySubSeq.length << " ";
    *outputPtr << g *1.0 / qrySubSeq.length << " ";

    *outputPtr << CountRepeatMasked(refSubSeq) << " ";
    refSubSeq.PrintSeq(*outputPtr, 100000);
    *outputPtr << " ";
    *outputPtr << CountRepeatMasked(qrySubSeq) << " ";
    qrySubSeq.PrintSeq(*outputPtr, 100000);
    *outputPtr << std::endl;
  }
  return 0;
}

float AlignSubsequences(DNASequence &refSeq, int refPos, int refLength, 
			DNASequence &qrySeq, int qryPos, int qryLength,
			int *&locations, // map of refseq to qryseq
			int &length, // length of optimal local alignment
			int &refAlignStart, // start of local alignment in ref seq
			int &qryAlignStart, // start of local alignment in qry seq
			FloatMatrix &scoreMat, int extendAlignment) {
  DNASequence refSubseq, qrySubseq, qrySubseqRC;
  float alignScore;
  int   *enumerations;
  refSubseq.seq = &(refSeq.seq[refPos]);
  refSubseq.length = refLength;
  qrySubseq.seq = &(qrySeq.seq[qryPos]);
  qrySubseq.length = qryLength;
  
  MakeRC(qrySubseq, qrySubseqRC);
  
  int *totalAlignment; // alignment along full length of refSeq, not just 
                       //  optimal local alignment
  totalAlignment = new int[refSubseq.length];
  alignScore = AffineLocalAlign(refSubseq, qrySubseqRC, 
				-100, // match
				200,  // general mismatch
				800,  // general gap
				400,  // general gap-open
				30,   // general gap-extend
				totalAlignment,  // resulting alignment
				scoreMat// custom scoring matrix
				);

  if (extendAlignment) {
    int pos, i;
    int *extendedAlignment;
    DNASequence refExt, qryExtRC;
    int startRefAlign, endRefAlign, startQryAlign, endQryAlign;
    pos = 0;
    while (pos < refSubseq.length && totalAlignment[pos] == -1) pos++;
    startRefAlign = pos;
    startQryAlign = totalAlignment[pos];
    int refAlignStart, qryAlignStart;
    pos = refSubseq.length-1;
    while (pos > 0 && totalAlignment[pos] == -1 ) pos--;
    endRefAlign = pos;
    endQryAlign = totalAlignment[pos];
    
    extendedAlignment = new int[refSubseq.length - endRefAlign + 1];
    for (i = 0; i < refSubseq.length - pos + 1; i++) extendedAlignment[i] = -1;
    
    qryExtRC.seq = &qrySubseqRC.seq[totalAlignment[pos]];
    qryExtRC.length = qrySubseqRC.length - totalAlignment[pos] + 1;
    int extLen;
    extLen = 0;
    ScoreBandedAffineAlign(refSubseq, qrySubseqRC, alignScore, scoreMat, 
			   400,  30, alignScore-1500, extendedAlignment, extLen,
			   refAlignStart, qryAlignStart,
			   endRefAlign+1, endQryAlign+1, 1);

    std::cout << " extended alignemnt of score : " << alignScore << " " << extLen << std::endl;
    extendedAlignment = new int[startRefAlign];
    for (i = 0; i < startRefAlign; i++) extendedAlignment[i] = -1;
    extLen = 0;
    ScoreBandedAffineAlign(refSubseq, qrySubseqRC, alignScore, scoreMat, 
			   400,  30, alignScore-1500, extendedAlignment, extLen,
			   refAlignStart, qryAlignStart,
			   startRefAlign-1, startQryAlign-1, -1);

    std::cout << " extended alignemnt of score : " << alignScore << " " << extLen << std::endl;
    
    PrintAlignment(&std::cout, refExt, qryExtRC, extendedAlignment, 1, extLen);
  }

  // Make the alignment reference into the + query strand
  RotateAlignment(totalAlignment, refSubseq.length, qrySubseq.length);

  // The alignment is a local alignment, so only 
  // the local alignment needs to be stored.  
  // a. count the length of the alignment.
  
  length = 0;
  int s, e, i;
  s = 0;
  // Find the first aligned position in refseq.
  while (totalAlignment[s] == -1 && s < refSubseq.length) s++;
  e = refSubseq.length-1;
  // find the last aligned position in refseq
  while (totalAlignment[e] == -1 && e > s) e--;
  if (e <= s) {
    length = 0;
    locations = NULL;
  }
  else {
    length = e - s + 1;
    refAlignStart = s; // index into alignment
    qryAlignStart = totalAlignment[e]; // end of the alignment is least value

    locations = new int[length];
    for (i = 0; i < length; i++) 
      if (totalAlignment[i+s] != -1) 
	locations[i] = totalAlignment[i+s] - qryAlignStart; // consider offset into query.
      else 
	locations[i] = -1;

  }

  delete []totalAlignment;
  delete []qrySubseqRC.seq;

  return alignScore;
}




void InitEnv(int argc, char* argv[], 
	     std::string &refSeqName, 
	     std::string &qrySeqName,
	     std::string &scaffoldName,
	     std::string &scoreMatFile,
	     std::string &scoreMatString,
	     std::string &alignOutput,
	     std::string &outputFile,
	     float &tailEndPct,
	     int &window, int &step,
	     int &extendAlignment ) {

  int copt;
  int i;
  std::string inpfile;
  while ( (copt=getopt(argc, argv, "w:s:m:S:o:a:t:e")) != EOF){
    switch(copt) {
    case 'e':
      extendAlignment = 1;
      continue;
    case 'o':
      outputFile = optarg;
      continue;
    case 'a':
      alignOutput = optarg;
      continue;
    case 't':
      tailEndPct = atof(optarg);
      continue;
    case 'w':
      window = atoi(optarg);
      continue;
    case 's':
      step = atoi(optarg);
      continue;
    case 'm':
      scoreMatFile = optarg;
      continue;
    case 'S':
      scoreMatString = optarg;
      continue;
    default:
      PrintUsage();
      exit(1);
    }
  }
  i = optind;
  if (i >= argc) {
    std::cout << "You must specify a reference seq and query seq. " << std::endl;
    PrintUsage();
    exit(1);
  }
  refSeqName = argv[i];
  i++;
  if (i >= argc) {
    std::cout << "You must specify a query seq. " << std::endl;
    PrintUsage();
    exit(1);
  }
  qrySeqName = argv[i];
  i++;
  if (i >= argc) {
    std::cout << "You must specify a scaffold. " << std::endl;
    PrintUsage();
    exit(1);
  }
  scaffoldName = argv[i];

}


void PrintUsage() {
  std::cout << "InvFinder.  A program to find inversions in two sequences. " << std::endl;
  std::cout << "usage: invfinder [-otmswe] refseq queryseq scaffold " << std::endl;
  std::cout << "-e   : extend each best match using affine gapped extension " << std::endl;
  std::cout << "-m scoreMatFile : use scoring matrix scoremat " << std::endl;
  std::cout << "-s scoreMatStr  : use scoring matrix string that specifies the 25 values of scoremat" << std::endl;
  std::cout << "-t tailEndPct   : output top t percent of alignment lengths " << std::endl;
}

int NestedInversion(int pos, int *enumerations, int *startQryLocations, int *endQryLocations) {
  std::cout << "in nested inversion with: " << enumerations[pos] << " " << enumerations[pos+1] 
	    << " " << enumerations[pos+2] << " " << startQryLocations[pos] <<  " "  
	    << startQryLocations[pos+1]  <<  " " << startQryLocations[pos+2]  << " " <<  endQryLocations[pos+1]  
	    << Sign(enumerations[pos]) << " " << Sign(enumerations[pos+1]) 
	    << " " << Sign(enumerations[pos+2]) << std::endl;
    
  if (Sign(enumerations[pos]) == -1*Sign(enumerations[pos+1]) &&
      Sign(enumerations[pos+1]*-1) == Sign(enumerations[pos+2])) {
    std::cout << "proper signs " << std::endl;
    if (startQryLocations[pos+2] > startQryLocations[pos+1] && 
	startQryLocations[pos+1] > endQryLocations[pos] &&
	startQryLocations[pos+2] > endQryLocations[pos+1] &&
	endQryLocations[pos+1] > endQryLocations[pos]) {
      std::cout << "found ni " << std::endl;
      return 1;
    }
    else
      return 0;
  }
  else 
    return 0;
  
}


float AlignAroundPosition(DNASequence &refSeq, int refStartPos, int refEndPos,
			  DNASequence &qrySeq, int qryStartPos, int qryEndPos,
			  int *&locations, // map of refseq to qryseq
			  int &length, // length of optimal local alignment
			  int &refStartAlignPos, int &qryStartAlignPos,
			  FloatMatrix &scoreMat) {
  std::cout << "aligning around position: " << refStartPos << std::endl; 
  DNASequence qrySubseqRC;

  MakeRC(qrySeq, qrySubseqRC);

  
  int pos, i;
  int *forAlignment, *backAlignment;
  int forLength, backLength;
  DNASequence refExt, qryExtRC;
  int startRefAlign, endRefAlign, startQryAlign, endQryAlign;
  pos = 0;
  float alignScore;
  int forRefAlignStart, forQryAlignStart, backRefAlignStart, backQryAlignStart;
  alignScore = (refEndPos - refStartPos+1)*scoreMat[0][0];

  backAlignment = new int[refStartPos];
  for (i = 0; i < refStartPos; i++) backAlignment[i] = -1;

  
  ScoreBandedAffineAlign(refSeq, qrySubseqRC, alignScore, scoreMat, 
			 400,  30, alignScore -1500, backAlignment, backLength,
			 backRefAlignStart, backQryAlignStart,
			 refStartPos-1, qryStartPos-1, -1);
  
  ScoreBandedAffineAlign(refSeq, qrySubseqRC, alignScore, scoreMat, 
			 400,  30, alignScore-1500, forAlignment, forLength,
			 forRefAlignStart, forQryAlignStart,
			 refEndPos+1, qryEndPos+1, 1);

  std::cout << "aligning ref seq " << std::endl;
  refSeq.PrintSeq(std::cout);
  std::cout << "qry rc: " << std::endl;
  qrySubseqRC.PrintSeq(std::cout);
  std::cout << " extended alignemnt of score : " << alignScore << " " << forLength << std::endl;
    
  PrintAlignment(&std::cout, refSeq, qrySubseqRC, forAlignment , 1, forLength);

  // Now join the two alignments into one larger one.

  length = backLength + (refEndPos - refStartPos+1) + forLength;

  locations = new int[length];
  pos = 0;
  // copy the back alignment
  for(i =0; i < backLength; i++, pos++) {
    locations[pos] = backAlignment[i];
  }
  // copy the seed
  for(i = 0; i < refEndPos - refStartPos+1; i++, pos++) {
    locations[pos] = qryStartPos + i;
  }
  // copy the forward alignment
  for (i = 0; i < forLength; i++, pos++) {
    locations[pos] = forAlignment[i];
  }

}
