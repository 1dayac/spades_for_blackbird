\documentclass[17pt]{extarticle}
\usepackage{ifpdf}
\ifpdf
\usepackage{cmap}
\fi
\usepackage[english]{babel}
\usepackage{palatino}
\usepackage[x11names,svgnames]{xcolor}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{tikz}
\usepackage{amsthm}
\usepackage{pgf}
\usepackage{multicol}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage[section]{algorithm} % [section] is use to define the numbering mode
\usepackage{algorithmic} 
\usepackage[a1paper,left=4cm,right=3cm,top=2cm,bottom=1cm,foot=0cm]{geometry}
\usepackage{poster}
\usepackage{booktabs}
\usepackage{multirow,multicol}


\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{theorem}{Theorem}[section]
                             
\begin{document}
\pagestyle{empty}
\noindent\hspace{-2cm}\begin{tikzpicture}[rounded corners=2cm,x=1cm,y=1cm]
  \draw (0,-1) [color=SteelBlue3,line width=2mm] rectangle (55.5,79);
\end{tikzpicture}
\vspace{-78.5cm}
\begin{center}
    {\color{OrangeRed} \fontsize{64pt}{1em} {\bf Earmark graph approach to {\it de novo} genome assembly}}
    \vspace{1.5cm}
    
    \fontsize{32pt}{2.5em}\selectfont
    \color{DodgerBlue3}

    {\bf Mikhail Dvorkin, Alexander S. Kulikov, Max Alekseyev}

    {affiliations}

    {\tt emails}

\end{center}%
\vspace{1cm}

\begin{multicols}{2}
%\section{NB!}
%This is just a copypasted text.

\section{Introduction}
A common approach to assembling a genome from short reads is constructing
the de Bruijn graph \cite{PW01} on all $k$-mers from the given set of 
reads and finding a traversal of edges in this graph.
%Namely, the set of all $k$-mers form the set of vertices of the graph
%and two $k$-mers $A$ and $B$ are joined by a directed edge if there is a read
%where the $k$-mer $B$ appears 
An example of the de Bruijn graph for $k=3$ and a set of all reads of length $6$
of a (circular) genome $g={\tt ATGCATTGCACTGCA}$ is given in Fig.~\ref{fig:debruijn}a
(edges multiplicities are not shown). The genome spells a Chinese Postman
cycle in the de Bruijn graph.

%\begin{figure}
%\caption{(a) The de Bruijn graph built on $3$-mers 
%of all $6$-reads of a toy genome {\tt ATGCATTGCACTGCA}.
%(b) The earmark graph build on the same set of reads with all $3$-mers earmarked except for
%{\tt TGC} and {\tt GCA}.}\label{fig:debruijn}
\begin{center}
a\includegraphics[width=0.4\textwidth]{ATGCATTGCACTGCA_debruijn.pdf}\\
b\includegraphics[width=0.4\textwidth]{ATGCATTGCACTGCA_earmark.pdf}\\
%\includegraphics[width=0.9\textwidth]{ATGCATTGCACTGCA_earmark2.pdf}\\
\end{center}
%\end{figure}

The size of the de Bruijn graph for most genomes is huge making
it difficult to process. 
We propose a new approach that allows to decrease
the graph size without losing the essential information from the input data.
Instead of using all the $k$-mers from a read we take only some fraction of them
(and call them \emph{earmarked}).
Namely, instead 
of representing each read as a sequence of edges 
between its consecutive $k$-mers (in which case a read of length $r$ defines
$r-k-1$ edges) we represent it as just one (or a few, in general)
edge between some of its $k$-mers. For example, for 
reads {\tt ACGTACT} and {\tt TACTAGC} and $k=3$
instead of all gray edges in the figure below we will have 
only two black edges joining earmarked $k$-mers {\tt ACG}, {\tt ACT}, and {\tt AGC}.
\begin{center}
\includegraphics[width=0.4\textwidth]{fig1.pdf}
\end{center}
We call the resulting graph built on earmarked $k$-mers \emph{an earmark graph}.
It is a special case of the A-Bruijn graph introduced by Pevzner, Tang, and Tesler \cite{PTG04}.
An example of the earmark graph for the same genome $g={\tt ATGCATTGCACTGCA}$ is shown in Fig.~\ref{fig:debruijn}b.
Here, all $3$-mers are earmarked except for {\tt TGC} and {\tt GCA}.
Besides an obvious advantage of requiring less memory 
and time for constructing, the resulting earmark graph has several other advantages over the
de Bruijn graph. We discuss them 
%after all the necessary definitions.
in Section~\ref{sec:advantages}.

Our approach is inspired by the work by Roberts et al. \cite{RW04} on sequence comparison.
The problem they studied is a pairwise comparison of a set of strings. 
One of the approaches to this problem is the seed-and-extend approach.
One first stores the set of all possible $k$-mers from a given set of strings.
Then, only pairs of strings that both have the same $k$-mer as a substring are compared.
This allows to avoid comparing all pairs of input strings. However the database
of all $k$-mers may be really huge. To reduce the storage requirements Roberts et al. propose
to select not all the $k$-mers, but only those that are minimal in an input string with respect
to a certain order. Such $k$-mers are called \emph{minimizers}. Our earmarked $k$-mers are close in spirit 
to minimizers.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Earmark graph}
In a typical genome assembly setting, one is given a set 
${\cal R} \subseteq \{A,C,G,T\}^r$ 
of substrings of length $r$ of an unknown genome $S \in \{A,C,G,T\}^*$.
The elements of ${\cal R}$ are usually called reads or $r$-reads.
For a read $R$ and indices $1 \le i \le j \le r$,
let $R[i,j]$ be a substring of $R$ starting at position $i$
and ending at position $j$. By a $k$-mer we mean any string from
$\{A,C,G,T\}^k$. Throughout the rest of the paper $r$ and $k<r$
refer, respectively, to read and mer size.

A \emph{de Bruijn graph} $\textrm{DG}_k({\cal R})$ is defined as follows:
\begin{itemize}
\item the set of all substrings of length $k$ (usually called $k$-mers) of the given reads is the 
set of vertices; 
\item two $k$-mers $A$ and $B$ are joined by a directed edge if there is a
read $R \in {\cal R}$ and an index $1 \le i \le r-k-1$ such that
%$A$ and $B$ are substrings of $R$ starting at positions $i$ and $i+1$, respectively 
$A=R[i,i+k-1]$ and $B=R[i+1,i+k]$
(this, in particular, implies that
the suffix of $A$ of length $k-1$ equals the prefix of $B$ of the same length).
\end{itemize}
Note that each read $R \in {\cal R}$ is represented by a path of length $r-k-1$
on its $k$-mers in $\textrm{DG}_k({\cal R})$.


An earmark graph can be viewed as the de Bruijn graph
with some paths contracted into a single edge.
Let ${\cal E} \subseteq \{A,C,G,T\}^k$ be a set of $k$-mers.
Below we refer to it as a \emph{set of earmarks} or as a \emph{set of earmarked $k$-mers}. 
An \emph{earmark graph} $\textrm{EG}_k({\cal R}, {\cal E})$ is defined as follows:
\begin{itemize}
\item ${\cal E}$ is the set of vertices;
\item two $k$-mers $A, B \in {\cal E}$ are joined by a directed edge if there is a read $R \in {\cal R}$
and indices $1 \le i < j \le r-k-1$ such that
$A=R[i,i+k-1]$ and $B=R[j,j+k-1]$ and 
for any $i < t < j$, $R[t,t+k-1] \not \in {\cal E}$
(i.e., $B$ is the next earmarked $k$-mer after $A$ in $R$); the length of this edge is set to
$j-i$.
\end{itemize}
Hence, in the earmark graph each read is represented as a path (of length at most $r-k-1$) on its earmarked $k$-mers.
When constructing an earmark graph it is reasonable to ensure that each read contains at least two 
earmarked $k$-mers (so that the length of the corresponding path is at least one).
It is easy to see that in the special case when all the possible $k$-mers are earmarked
the earmark graph coincides with the de Bruijn graph.

Both de Bruijn and earmark graphs are built on a set of reads that can be viewed as a 
set of reads from an unknown genome. A natural way to build these two graphs on a genome
itself is to use the set of all its reads of a particular length. Namely, 
for a genome $S \in \{A,C,G,T\}^*$, define $\Gamma_r(S) \subseteq \{A,C,G,T\}^r$
as a set of all $r$-mers appearing in $S$. Then $\textrm{DG}_k(S)$ and $\textrm{EG}_k(S, {\cal E})$
are just $\textrm{DG}_k(\Gamma_r(S))$ and $\textrm{EG}_k(\Gamma_r(S), {\cal E})$, respectively.
It is easy to see that the genome $S$ spells a Chinese Postman cycle in 
$\textrm{DG}_k(S)$.

%This defintion can be used in a natural way to build the de Bruijn graph not on a set of reads,
%but on a genome. Namely, for a genome $S \in \{A,C,G,T\}^*$, define $\Gamma_r(S) \subseteq \{A,C,G,T\}^k$
%as a set of all $r$-mers appearing in $S$. Then, $\textrm{DB}()$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Selection of earmarks}
%In this section, we discuss 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Earmark graph construction}
%In this section, we give a high-level description of the main parts of the assembler.
In this section, we give a high-level description of an earmark graph construction procedure.
When the graph is constructed we simplify it using methods similar to the ones used in
EULER \cite{PW01} and Velvet \cite{Z08}.

We first construct an initial set of earmarks and then extend it to reduce 
the number of tips
%in the resulting graph. 
resulted from bad choice of earmarks.

\subsection{Earmarks selection procedure}
To construct an initial set of earmarks ${\cal E}$, we select from each given read 
several $k$-mers that are minimial with respect to some ordering. Namely, 
let $h$ be a hash-function on the set of all possible $k$-mers and $t$ be a 
fixed integer parameter.
We then select initial earmarks as follows.


%\begin{enumerate}
%\item For each read, select $t$ minimum hash values of its 
%$k$-mers and add them to the global set of earmarked hash values.
%\item If $t=1$, earmark the second smallest hash value for each read
%with only one $k$-mer with earmarked hash value. This guarantees that each read has at least
%two $k$-mers with earmarked hash values.
%\item Add to ${\cal E}$ all $k$-mers that have their hash values earmarked.
%%In each read, select $k$-mers that have their hash values earmarked.
%%For corresponding vertices in the resulting A Bruijn graph, add all pairwise edges, storing their lengths.
%%\item For each $k$-mer that has no left or right neighbours, find a neighbour on the corresponding side
%%that has the smallest hash value and earmark it.
%%\item Repeat the previous step to minimize the number of neighbourless $k$-mers.
%\end{enumerate}

\begin{algorithm}
\caption{EarmarksSelection(${\cal R}$, $h$, $t$)}
\label{alg:earmarksselection}
\begin{algorithmic}[1] % line numbering every fifth line
  \STATE ${\cal E} \gets \emptyset$ \COMMENT{set of earmarked $k$-mers}
  \STATE ${\cal H} \gets \emptyset$ \COMMENT{set of earmarked hash values}
  \FORALL{$R \in {\cal R}$}
    \STATE find $t$ minimum hash values of all the $k$-mers of $R$ and 
    add them to ${\cal H}$
  \ENDFOR
  \IF {$t=1$}
    \FORALL{$R \in {\cal R}$ with only one $k$-mer with earmarked hash value}
      \STATE add to ${\cal H}$ the second smallest hash value of all the 
      $k$-mers of $R$
    \ENDFOR
  \ENDIF
  \FORALL{$R \in {\cal R}$}
    \FORALL{$k$-mers $K$ of $R$}
      \IF {$h(K) \in {\cal H}$}
        \STATE ${\cal E} = {\cal E} \cup \{K\}$
      \ENDIF
    \ENDFOR
  \ENDFOR
  \RETURN ${\cal E}$
\end{algorithmic}
\end{algorithm}

We mark hash values but not $k$-mers themselves to reduce the space 
required to store what is marked. This way some $k$-mers may be unwillingly marked due 
to collisions, but in case of a reasonable hash function the number of 
such collisions is negligible.


\subsection{Tip extension procedure}
Assume that we are given a set of reads ${\cal R}$ of an unknown genome $S$.
It is easy to see that parts of the genome $S$ that are not covered by any read
from ${\cal R}$ create vertices of in- or our-degree one in $\textrm{DG}_k({\cal R})$.
Such vertices are called \emph{tips}. At the same time, the earmark graph may contain
tips not only because of coverage gaps, but also tips resulting from a bad choice of the 
set of earmarks. 

To give an example,
consider two reads {\tt TATGCA} and {\tt GCATCC}.
The corresponding path in the de Bruijn graph is shown in 
Fig.~{fig:tipexample}(a). Assume now that only $3$-mers
{\tt ATG}, {\tt TGC}, {\tt CAT}, and {\tt TCC} are earmarked.
Then the corresponding part of the earmark graph contains two tips 
(Fig.~{fig:tipexample}(b)). To avoid it we earmark also the $3$-mer
{\tt GCA}.

\begin{figure}
\caption{(a) Part of the de Bruijn graph corresponding to reads 
{\tt TATGCA} and {\tt GCATCC}. (b) The corresponding part 
of the earmarked graph has a gap if the $3$-mer {\tt GCA} is not 
earmarked. (c) The gap can be avoided by earmarking the $3$-mer 
{\tt GCA}.}\label{fig:tipexample}
\begin{center}
a\includegraphics[width=0.4\textwidth]{fig5_de.pdf}\\
b\includegraphics[width=0.4\textwidth]{fig5_ear.pdf}\\
c\includegraphics[width=0.4\textwidth]{fig5_earwotip.pdf}\\
\end{center}
\end{figure}

%To give an example,
%%Due to the fact that not all the k-mers are represented in the A-Bruijn graph,
%%some extra gaps can be unwillingly created.
%consider a genome substring $ABCDE$, where $B$ and $D$ are earmarked $k$-mers.
%If none of the reads in the input data contain the whole substring $BCD$, then vertices corresponding to
%$B$ and $D$ will be tips in the earmark graph.
%Meanwhile reads containing $ABC$ and $CDE$ may be present in the input data (and hence the whole considered
%part is covered by reads), so these vertices must not be tips.
%%thus it is an error of the approach
%%to call this vertices tips and to introduce a gap here.

The tip extension procedure is suggested to handle this issue.
It consists of three steps that are repeated consequently until 
no possible tip extensions are present.
(Each steps demands reading the entire input data. It is possible to reduce the procedure to less than three
steps, but much more memory will be used in that case).

%\todo[inline]{write as a pseudocode}

\begin{enumerate}
\item By processing all the reads, find out for each earmarked $k$-mer, whether we have seen any
earmarked $k$-mer to the left of it and to the right from it.
Those earmarked $k$-mers that do not have either left or right ``neighbours'' are called left and right tips,
respectively.
\item By processing all the reads, find the collection of all the non-earmarked $k$-mers that
are present (at least once) in a read to the left of a left tip, or to the right of the right tip.
Call them possible tip extensions.
\item By processing all the reads, for each possible tip extension, record whether there was
any earmarked $k$-mer to the left of it and to the right of it.
\end{enumerate}

Now that this information is collected, each tip is being extended with
a possible tip extension using the following rules (in the order preference).

\begin{enumerate}
\item Check if any of its possible tip extensions was already selected as an earmark
(as a tip extension for some previously processed tip, using rules 2 and 3 below).
If so, continue to the next tip.
\item Check if any of its possible tip extensions has both left and right neighbours.
We select this extension as an earmark and thus eliminate at least one undesirable tip.
\item Select as an earmark the possible tip extension that is most distant (in base pairs)
from the tip being proccesed. Doing this, we do not eliminate a tip but we extend it as far
as possible. This helps us not to lose information near the actual gaps (or the ends of actual scaffolds).
\end{enumerate}

If no new earmarked $k$-mers were introduced after this procedure, then stop, otherwise repeat the entire procedure.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advantages of the earmark graph over the de Bruijn 
graph}\label{sec:advantages}

\begin{description}
\item[Smaller size.]
The earmark graph requires less time and memory for construction.
Note also that one can control the size of the earmark graph 
by varying the size of the set of earmarks (e.g., by varying the parameter $t$
of Algorithm~\ref{alg:earmarksselection}).
\item[Some of short repeats are already resolved.]
To give an example, consider two reads {\tt TTGCAC} and {\tt ATGCAT}.
%\todo[inline]{complete}

\begin{figure}
\caption{???}\label{fig:repeatexample}
\begin{center}
a\includegraphics[width=0.9\textwidth]{fig6_de.pdf}\\
b\includegraphics[width=0.9\textwidth]{fig6_ear.pdf}\\
\end{center}
\end{figure}

\item[Less errors.] Erroneous $k$-mers can be excluded from the graph already on
the construction stage.
Blah-blah-blah
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Practical results}
%\todo[inline]{fill in Table~\ref{table:practical}}

\begin{table}
\begin{center}
\begin{tabular}{llcc}
\toprule
& & earmarked & de Bruijn\\

\midrule
\multirow{3}{*}{first 10\% of E.coli w/o simplification} & \# vertices & ??????? & ???????\\
\cmidrule(r){2-4}
& \# edges & ??????? & ???????\\
\cmidrule(r){2-4}
& \# tips (?) & ??????? & ???????\\

\midrule
\multirow{3}{*}{first 10\% of E.coli after simplification} & \# vertices & ??????? & ???????\\
\cmidrule(r){2-4}
& \# edges & ??????? & ???????\\
\cmidrule(r){2-4}
& \# tips (?) & ??????? & ???????\\

\midrule
\multirow{3}{*}{E.coli after simplification} & \# vertices & ??????? & ???????\\
\cmidrule(r){2-4}
& \# edges & ??????? & ???????\\
\cmidrule(r){2-4}
& \# tips (?) & ??????? & ???????\\

\bottomrule
\end{tabular}
\caption{Practical results}\label{table:practical}
\end{center}
\end{table}

\end{multicols}

\end{document}
